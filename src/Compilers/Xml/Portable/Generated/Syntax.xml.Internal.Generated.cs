// <auto-generated />

using System;
using System.Collections;
using System.Collections.Generic;
using System.Linq;
using System.Threading;
using Microsoft.CodeAnalysis.Syntax.InternalSyntax;
using Roslyn.Utilities;

namespace Microsoft.CodeAnalysis.Xml.Syntax.InternalSyntax
{
  internal abstract partial class XmlNodeSyntax : XmlSyntaxNode
  {
    internal XmlNodeSyntax(SyntaxKind kind, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
      : base(kind, diagnostics, annotations)
    {
    }
    internal XmlNodeSyntax(SyntaxKind kind)
      : base(kind)
    {
    }

    protected XmlNodeSyntax(ObjectReader reader)
       : base(reader)
    {
    }
  }

  /// <summary>Provides the base class from which the classes that represent type syntax nodes are derived. This is an abstract class.</summary>
  internal abstract partial class TypeSyntax : XmlSyntaxNode
  {
    internal TypeSyntax(SyntaxKind kind, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
      : base(kind, diagnostics, annotations)
    {
    }
    internal TypeSyntax(SyntaxKind kind)
      : base(kind)
    {
    }

    protected TypeSyntax(ObjectReader reader)
       : base(reader)
    {
    }
  }

  /// <summary>Provides the base class from which the classes that represent name syntax nodes are derived. This is an abstract class.</summary>
  internal abstract partial class NameSyntax : TypeSyntax
  {
    internal NameSyntax(SyntaxKind kind, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
      : base(kind, diagnostics, annotations)
    {
    }
    internal NameSyntax(SyntaxKind kind)
      : base(kind)
    {
    }

    protected NameSyntax(ObjectReader reader)
       : base(reader)
    {
    }
  }

  /// <summary>Provides the base class from which the classes that represent simple name syntax nodes are derived. This is an abstract class.</summary>
  internal abstract partial class SimpleNameSyntax : NameSyntax
  {
    internal SimpleNameSyntax(SyntaxKind kind, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
      : base(kind, diagnostics, annotations)
    {
    }
    internal SimpleNameSyntax(SyntaxKind kind)
      : base(kind)
    {
    }

    protected SimpleNameSyntax(ObjectReader reader)
       : base(reader)
    {
    }

    /// <summary>SyntaxToken representing the identifier of the simple name.</summary>
    public abstract SyntaxToken Identifier { get; }
  }

  internal sealed partial class XmlBodySyntax : XmlSyntaxNode
  {
    internal readonly GreenNode elements;
    internal readonly SyntaxToken endOfFileToken;

    internal XmlBodySyntax(SyntaxKind kind, GreenNode elements, SyntaxToken endOfFileToken, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
        : base(kind, diagnostics, annotations)
    {
        this.SlotCount = 2;
        if (elements != null)
        {
            this.AdjustFlagsAndWidth(elements);
            this.elements = elements;
        }
        this.AdjustFlagsAndWidth(endOfFileToken);
        this.endOfFileToken = endOfFileToken;
    }


    internal XmlBodySyntax(SyntaxKind kind, GreenNode elements, SyntaxToken endOfFileToken, SyntaxFactoryContext context)
        : base(kind)
    {
        this.SetFactoryContext(context);
        this.SlotCount = 2;
        if (elements != null)
        {
            this.AdjustFlagsAndWidth(elements);
            this.elements = elements;
        }
        this.AdjustFlagsAndWidth(endOfFileToken);
        this.endOfFileToken = endOfFileToken;
    }


    internal XmlBodySyntax(SyntaxKind kind, GreenNode elements, SyntaxToken endOfFileToken)
        : base(kind)
    {
        this.SlotCount = 2;
        if (elements != null)
        {
            this.AdjustFlagsAndWidth(elements);
            this.elements = elements;
        }
        this.AdjustFlagsAndWidth(endOfFileToken);
        this.endOfFileToken = endOfFileToken;
    }

    public Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<XmlSyntaxNode> Elements { get { return new Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<XmlSyntaxNode>(this.elements); } }
    public SyntaxToken EndOfFileToken { get { return this.endOfFileToken; } }

    internal override GreenNode GetSlot(int index)
    {
        switch (index)
        {
            case 0: return this.elements;
            case 1: return this.endOfFileToken;
            default: return null;
        }
    }

    internal override SyntaxNode CreateRed(SyntaxNode parent, int position)
    {
      return new Xml.Syntax.XmlBodySyntax(this, parent, position);
    }

    public override TResult Accept<TResult>(XmlSyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitXmlBody(this);
    }

    public override void Accept(XmlSyntaxVisitor visitor)
    {
        visitor.VisitXmlBody(this);
    }

    public XmlBodySyntax Update(Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<XmlSyntaxNode> elements, SyntaxToken endOfFileToken)
    {
        if (elements != this.Elements || endOfFileToken != this.EndOfFileToken)
        {
            var newNode = SyntaxFactory.XmlBody(elements, endOfFileToken);
            var diags = this.GetDiagnostics();
            if (diags != null && diags.Length > 0)
               newNode = newNode.WithDiagnosticsGreen(diags);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               newNode = newNode.WithAnnotationsGreen(annotations);
            return newNode;
        }

        return this;
    }

    internal override GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics)
    {
         return new XmlBodySyntax(this.Kind, this.elements, this.endOfFileToken, diagnostics, GetAnnotations());
    }

    internal override GreenNode SetAnnotations(SyntaxAnnotation[] annotations)
    {
         return new XmlBodySyntax(this.Kind, this.elements, this.endOfFileToken, GetDiagnostics(), annotations);
    }

    internal XmlBodySyntax(ObjectReader reader)
        : base(reader)
    {
      this.SlotCount = 2;
      var elements = (GreenNode)reader.ReadValue();
      if (elements != null)
      {
         AdjustFlagsAndWidth(elements);
         this.elements = elements;
      }
      var endOfFileToken = (SyntaxToken)reader.ReadValue();
      if (endOfFileToken != null)
      {
         AdjustFlagsAndWidth(endOfFileToken);
         this.endOfFileToken = endOfFileToken;
      }
    }

    internal override void WriteTo(ObjectWriter writer)
    {
      base.WriteTo(writer);
      writer.WriteValue(this.elements);
      writer.WriteValue(this.endOfFileToken);
    }

    static XmlBodySyntax()
    {
       ObjectBinder.RegisterTypeReader(typeof(XmlBodySyntax), r => new XmlBodySyntax(r));
    }
  }

  /// <summary>Class which represents the syntax node for identifier name.</summary>
  internal sealed partial class IdentifierNameSyntax : SimpleNameSyntax
  {
    internal readonly SyntaxToken identifier;

    internal IdentifierNameSyntax(SyntaxKind kind, SyntaxToken identifier, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
        : base(kind, diagnostics, annotations)
    {
        this.SlotCount = 1;
        this.AdjustFlagsAndWidth(identifier);
        this.identifier = identifier;
    }


    internal IdentifierNameSyntax(SyntaxKind kind, SyntaxToken identifier, SyntaxFactoryContext context)
        : base(kind)
    {
        this.SetFactoryContext(context);
        this.SlotCount = 1;
        this.AdjustFlagsAndWidth(identifier);
        this.identifier = identifier;
    }


    internal IdentifierNameSyntax(SyntaxKind kind, SyntaxToken identifier)
        : base(kind)
    {
        this.SlotCount = 1;
        this.AdjustFlagsAndWidth(identifier);
        this.identifier = identifier;
    }

    /// <summary>SyntaxToken representing the keyword for the kind of the identifier name.</summary>
    public override SyntaxToken Identifier { get { return this.identifier; } }

    internal override GreenNode GetSlot(int index)
    {
        switch (index)
        {
            case 0: return this.identifier;
            default: return null;
        }
    }

    internal override SyntaxNode CreateRed(SyntaxNode parent, int position)
    {
      return new Xml.Syntax.IdentifierNameSyntax(this, parent, position);
    }

    public override TResult Accept<TResult>(XmlSyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitIdentifierName(this);
    }

    public override void Accept(XmlSyntaxVisitor visitor)
    {
        visitor.VisitIdentifierName(this);
    }

    public IdentifierNameSyntax Update(SyntaxToken identifier)
    {
        if (identifier != this.Identifier)
        {
            var newNode = SyntaxFactory.IdentifierName(identifier);
            var diags = this.GetDiagnostics();
            if (diags != null && diags.Length > 0)
               newNode = newNode.WithDiagnosticsGreen(diags);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               newNode = newNode.WithAnnotationsGreen(annotations);
            return newNode;
        }

        return this;
    }

    internal override GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics)
    {
         return new IdentifierNameSyntax(this.Kind, this.identifier, diagnostics, GetAnnotations());
    }

    internal override GreenNode SetAnnotations(SyntaxAnnotation[] annotations)
    {
         return new IdentifierNameSyntax(this.Kind, this.identifier, GetDiagnostics(), annotations);
    }

    internal IdentifierNameSyntax(ObjectReader reader)
        : base(reader)
    {
      this.SlotCount = 1;
      var identifier = (SyntaxToken)reader.ReadValue();
      if (identifier != null)
      {
         AdjustFlagsAndWidth(identifier);
         this.identifier = identifier;
      }
    }

    internal override void WriteTo(ObjectWriter writer)
    {
      base.WriteTo(writer);
      writer.WriteValue(this.identifier);
    }

    static IdentifierNameSyntax()
    {
       ObjectBinder.RegisterTypeReader(typeof(IdentifierNameSyntax), r => new IdentifierNameSyntax(r));
    }
  }

  /// <summary>Class which represents the syntax node for qualified name.</summary>
  internal sealed partial class QualifiedNameSyntax : NameSyntax
  {
    internal readonly NameSyntax left;
    internal readonly SyntaxToken dotToken;
    internal readonly SimpleNameSyntax right;

    internal QualifiedNameSyntax(SyntaxKind kind, NameSyntax left, SyntaxToken dotToken, SimpleNameSyntax right, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
        : base(kind, diagnostics, annotations)
    {
        this.SlotCount = 3;
        this.AdjustFlagsAndWidth(left);
        this.left = left;
        this.AdjustFlagsAndWidth(dotToken);
        this.dotToken = dotToken;
        this.AdjustFlagsAndWidth(right);
        this.right = right;
    }


    internal QualifiedNameSyntax(SyntaxKind kind, NameSyntax left, SyntaxToken dotToken, SimpleNameSyntax right, SyntaxFactoryContext context)
        : base(kind)
    {
        this.SetFactoryContext(context);
        this.SlotCount = 3;
        this.AdjustFlagsAndWidth(left);
        this.left = left;
        this.AdjustFlagsAndWidth(dotToken);
        this.dotToken = dotToken;
        this.AdjustFlagsAndWidth(right);
        this.right = right;
    }


    internal QualifiedNameSyntax(SyntaxKind kind, NameSyntax left, SyntaxToken dotToken, SimpleNameSyntax right)
        : base(kind)
    {
        this.SlotCount = 3;
        this.AdjustFlagsAndWidth(left);
        this.left = left;
        this.AdjustFlagsAndWidth(dotToken);
        this.dotToken = dotToken;
        this.AdjustFlagsAndWidth(right);
        this.right = right;
    }

    /// <summary>NameSyntax node representing the name on the left side of the dot token of the qualified name.</summary>
    public NameSyntax Left { get { return this.left; } }
    /// <summary>SyntaxToken representing the dot.</summary>
    public SyntaxToken DotToken { get { return this.dotToken; } }
    /// <summary>SimpleNameSyntax node representing the name on the right side of the dot token of the qualified name.</summary>
    public SimpleNameSyntax Right { get { return this.right; } }

    internal override GreenNode GetSlot(int index)
    {
        switch (index)
        {
            case 0: return this.left;
            case 1: return this.dotToken;
            case 2: return this.right;
            default: return null;
        }
    }

    internal override SyntaxNode CreateRed(SyntaxNode parent, int position)
    {
      return new Xml.Syntax.QualifiedNameSyntax(this, parent, position);
    }

    public override TResult Accept<TResult>(XmlSyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitQualifiedName(this);
    }

    public override void Accept(XmlSyntaxVisitor visitor)
    {
        visitor.VisitQualifiedName(this);
    }

    public QualifiedNameSyntax Update(NameSyntax left, SyntaxToken dotToken, SimpleNameSyntax right)
    {
        if (left != this.Left || dotToken != this.DotToken || right != this.Right)
        {
            var newNode = SyntaxFactory.QualifiedName(left, dotToken, right);
            var diags = this.GetDiagnostics();
            if (diags != null && diags.Length > 0)
               newNode = newNode.WithDiagnosticsGreen(diags);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               newNode = newNode.WithAnnotationsGreen(annotations);
            return newNode;
        }

        return this;
    }

    internal override GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics)
    {
         return new QualifiedNameSyntax(this.Kind, this.left, this.dotToken, this.right, diagnostics, GetAnnotations());
    }

    internal override GreenNode SetAnnotations(SyntaxAnnotation[] annotations)
    {
         return new QualifiedNameSyntax(this.Kind, this.left, this.dotToken, this.right, GetDiagnostics(), annotations);
    }

    internal QualifiedNameSyntax(ObjectReader reader)
        : base(reader)
    {
      this.SlotCount = 3;
      var left = (NameSyntax)reader.ReadValue();
      if (left != null)
      {
         AdjustFlagsAndWidth(left);
         this.left = left;
      }
      var dotToken = (SyntaxToken)reader.ReadValue();
      if (dotToken != null)
      {
         AdjustFlagsAndWidth(dotToken);
         this.dotToken = dotToken;
      }
      var right = (SimpleNameSyntax)reader.ReadValue();
      if (right != null)
      {
         AdjustFlagsAndWidth(right);
         this.right = right;
      }
    }

    internal override void WriteTo(ObjectWriter writer)
    {
      base.WriteTo(writer);
      writer.WriteValue(this.left);
      writer.WriteValue(this.dotToken);
      writer.WriteValue(this.right);
    }

    static QualifiedNameSyntax()
    {
       ObjectBinder.RegisterTypeReader(typeof(QualifiedNameSyntax), r => new QualifiedNameSyntax(r));
    }
  }

  internal sealed partial class XmlElementSyntax : XmlNodeSyntax
  {
    internal readonly XmlElementStartTagSyntax startTag;
    internal readonly GreenNode content;
    internal readonly XmlElementEndTagSyntax endTag;

    internal XmlElementSyntax(SyntaxKind kind, XmlElementStartTagSyntax startTag, GreenNode content, XmlElementEndTagSyntax endTag, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
        : base(kind, diagnostics, annotations)
    {
        this.SlotCount = 3;
        this.AdjustFlagsAndWidth(startTag);
        this.startTag = startTag;
        if (content != null)
        {
            this.AdjustFlagsAndWidth(content);
            this.content = content;
        }
        this.AdjustFlagsAndWidth(endTag);
        this.endTag = endTag;
    }


    internal XmlElementSyntax(SyntaxKind kind, XmlElementStartTagSyntax startTag, GreenNode content, XmlElementEndTagSyntax endTag, SyntaxFactoryContext context)
        : base(kind)
    {
        this.SetFactoryContext(context);
        this.SlotCount = 3;
        this.AdjustFlagsAndWidth(startTag);
        this.startTag = startTag;
        if (content != null)
        {
            this.AdjustFlagsAndWidth(content);
            this.content = content;
        }
        this.AdjustFlagsAndWidth(endTag);
        this.endTag = endTag;
    }


    internal XmlElementSyntax(SyntaxKind kind, XmlElementStartTagSyntax startTag, GreenNode content, XmlElementEndTagSyntax endTag)
        : base(kind)
    {
        this.SlotCount = 3;
        this.AdjustFlagsAndWidth(startTag);
        this.startTag = startTag;
        if (content != null)
        {
            this.AdjustFlagsAndWidth(content);
            this.content = content;
        }
        this.AdjustFlagsAndWidth(endTag);
        this.endTag = endTag;
    }

    public XmlElementStartTagSyntax StartTag { get { return this.startTag; } }
    public Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<XmlSyntaxNode> Content { get { return new Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<XmlSyntaxNode>(this.content); } }
    public XmlElementEndTagSyntax EndTag { get { return this.endTag; } }

    internal override GreenNode GetSlot(int index)
    {
        switch (index)
        {
            case 0: return this.startTag;
            case 1: return this.content;
            case 2: return this.endTag;
            default: return null;
        }
    }

    internal override SyntaxNode CreateRed(SyntaxNode parent, int position)
    {
      return new Xml.Syntax.XmlElementSyntax(this, parent, position);
    }

    public override TResult Accept<TResult>(XmlSyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitXmlElement(this);
    }

    public override void Accept(XmlSyntaxVisitor visitor)
    {
        visitor.VisitXmlElement(this);
    }

    public XmlElementSyntax Update(XmlElementStartTagSyntax startTag, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<XmlSyntaxNode> content, XmlElementEndTagSyntax endTag)
    {
        if (startTag != this.StartTag || content != this.Content || endTag != this.EndTag)
        {
            var newNode = SyntaxFactory.XmlElement(startTag, content, endTag);
            var diags = this.GetDiagnostics();
            if (diags != null && diags.Length > 0)
               newNode = newNode.WithDiagnosticsGreen(diags);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               newNode = newNode.WithAnnotationsGreen(annotations);
            return newNode;
        }

        return this;
    }

    internal override GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics)
    {
         return new XmlElementSyntax(this.Kind, this.startTag, this.content, this.endTag, diagnostics, GetAnnotations());
    }

    internal override GreenNode SetAnnotations(SyntaxAnnotation[] annotations)
    {
         return new XmlElementSyntax(this.Kind, this.startTag, this.content, this.endTag, GetDiagnostics(), annotations);
    }

    internal XmlElementSyntax(ObjectReader reader)
        : base(reader)
    {
      this.SlotCount = 3;
      var startTag = (XmlElementStartTagSyntax)reader.ReadValue();
      if (startTag != null)
      {
         AdjustFlagsAndWidth(startTag);
         this.startTag = startTag;
      }
      var content = (GreenNode)reader.ReadValue();
      if (content != null)
      {
         AdjustFlagsAndWidth(content);
         this.content = content;
      }
      var endTag = (XmlElementEndTagSyntax)reader.ReadValue();
      if (endTag != null)
      {
         AdjustFlagsAndWidth(endTag);
         this.endTag = endTag;
      }
    }

    internal override void WriteTo(ObjectWriter writer)
    {
      base.WriteTo(writer);
      writer.WriteValue(this.startTag);
      writer.WriteValue(this.content);
      writer.WriteValue(this.endTag);
    }

    static XmlElementSyntax()
    {
       ObjectBinder.RegisterTypeReader(typeof(XmlElementSyntax), r => new XmlElementSyntax(r));
    }
  }

  internal sealed partial class XmlElementStartTagSyntax : XmlSyntaxNode
  {
    internal readonly SyntaxToken lessThanToken;
    internal readonly XmlNameSyntax name;
    internal readonly GreenNode attributes;
    internal readonly SyntaxToken greaterThanToken;

    internal XmlElementStartTagSyntax(SyntaxKind kind, SyntaxToken lessThanToken, XmlNameSyntax name, GreenNode attributes, SyntaxToken greaterThanToken, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
        : base(kind, diagnostics, annotations)
    {
        this.SlotCount = 4;
        this.AdjustFlagsAndWidth(lessThanToken);
        this.lessThanToken = lessThanToken;
        this.AdjustFlagsAndWidth(name);
        this.name = name;
        if (attributes != null)
        {
            this.AdjustFlagsAndWidth(attributes);
            this.attributes = attributes;
        }
        this.AdjustFlagsAndWidth(greaterThanToken);
        this.greaterThanToken = greaterThanToken;
    }


    internal XmlElementStartTagSyntax(SyntaxKind kind, SyntaxToken lessThanToken, XmlNameSyntax name, GreenNode attributes, SyntaxToken greaterThanToken, SyntaxFactoryContext context)
        : base(kind)
    {
        this.SetFactoryContext(context);
        this.SlotCount = 4;
        this.AdjustFlagsAndWidth(lessThanToken);
        this.lessThanToken = lessThanToken;
        this.AdjustFlagsAndWidth(name);
        this.name = name;
        if (attributes != null)
        {
            this.AdjustFlagsAndWidth(attributes);
            this.attributes = attributes;
        }
        this.AdjustFlagsAndWidth(greaterThanToken);
        this.greaterThanToken = greaterThanToken;
    }


    internal XmlElementStartTagSyntax(SyntaxKind kind, SyntaxToken lessThanToken, XmlNameSyntax name, GreenNode attributes, SyntaxToken greaterThanToken)
        : base(kind)
    {
        this.SlotCount = 4;
        this.AdjustFlagsAndWidth(lessThanToken);
        this.lessThanToken = lessThanToken;
        this.AdjustFlagsAndWidth(name);
        this.name = name;
        if (attributes != null)
        {
            this.AdjustFlagsAndWidth(attributes);
            this.attributes = attributes;
        }
        this.AdjustFlagsAndWidth(greaterThanToken);
        this.greaterThanToken = greaterThanToken;
    }

    public SyntaxToken LessThanToken { get { return this.lessThanToken; } }
    public XmlNameSyntax Name { get { return this.name; } }
    public Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<XmlAttributeSyntax> Attributes { get { return new Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<XmlAttributeSyntax>(this.attributes); } }
    public SyntaxToken GreaterThanToken { get { return this.greaterThanToken; } }

    internal override GreenNode GetSlot(int index)
    {
        switch (index)
        {
            case 0: return this.lessThanToken;
            case 1: return this.name;
            case 2: return this.attributes;
            case 3: return this.greaterThanToken;
            default: return null;
        }
    }

    internal override SyntaxNode CreateRed(SyntaxNode parent, int position)
    {
      return new Xml.Syntax.XmlElementStartTagSyntax(this, parent, position);
    }

    public override TResult Accept<TResult>(XmlSyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitXmlElementStartTag(this);
    }

    public override void Accept(XmlSyntaxVisitor visitor)
    {
        visitor.VisitXmlElementStartTag(this);
    }

    public XmlElementStartTagSyntax Update(SyntaxToken lessThanToken, XmlNameSyntax name, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<XmlAttributeSyntax> attributes, SyntaxToken greaterThanToken)
    {
        if (lessThanToken != this.LessThanToken || name != this.Name || attributes != this.Attributes || greaterThanToken != this.GreaterThanToken)
        {
            var newNode = SyntaxFactory.XmlElementStartTag(lessThanToken, name, attributes, greaterThanToken);
            var diags = this.GetDiagnostics();
            if (diags != null && diags.Length > 0)
               newNode = newNode.WithDiagnosticsGreen(diags);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               newNode = newNode.WithAnnotationsGreen(annotations);
            return newNode;
        }

        return this;
    }

    internal override GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics)
    {
         return new XmlElementStartTagSyntax(this.Kind, this.lessThanToken, this.name, this.attributes, this.greaterThanToken, diagnostics, GetAnnotations());
    }

    internal override GreenNode SetAnnotations(SyntaxAnnotation[] annotations)
    {
         return new XmlElementStartTagSyntax(this.Kind, this.lessThanToken, this.name, this.attributes, this.greaterThanToken, GetDiagnostics(), annotations);
    }

    internal XmlElementStartTagSyntax(ObjectReader reader)
        : base(reader)
    {
      this.SlotCount = 4;
      var lessThanToken = (SyntaxToken)reader.ReadValue();
      if (lessThanToken != null)
      {
         AdjustFlagsAndWidth(lessThanToken);
         this.lessThanToken = lessThanToken;
      }
      var name = (XmlNameSyntax)reader.ReadValue();
      if (name != null)
      {
         AdjustFlagsAndWidth(name);
         this.name = name;
      }
      var attributes = (GreenNode)reader.ReadValue();
      if (attributes != null)
      {
         AdjustFlagsAndWidth(attributes);
         this.attributes = attributes;
      }
      var greaterThanToken = (SyntaxToken)reader.ReadValue();
      if (greaterThanToken != null)
      {
         AdjustFlagsAndWidth(greaterThanToken);
         this.greaterThanToken = greaterThanToken;
      }
    }

    internal override void WriteTo(ObjectWriter writer)
    {
      base.WriteTo(writer);
      writer.WriteValue(this.lessThanToken);
      writer.WriteValue(this.name);
      writer.WriteValue(this.attributes);
      writer.WriteValue(this.greaterThanToken);
    }

    static XmlElementStartTagSyntax()
    {
       ObjectBinder.RegisterTypeReader(typeof(XmlElementStartTagSyntax), r => new XmlElementStartTagSyntax(r));
    }
  }

  internal sealed partial class XmlElementEndTagSyntax : XmlSyntaxNode
  {
    internal readonly SyntaxToken lessThanSlashToken;
    internal readonly XmlNameSyntax name;
    internal readonly SyntaxToken greaterThanToken;

    internal XmlElementEndTagSyntax(SyntaxKind kind, SyntaxToken lessThanSlashToken, XmlNameSyntax name, SyntaxToken greaterThanToken, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
        : base(kind, diagnostics, annotations)
    {
        this.SlotCount = 3;
        this.AdjustFlagsAndWidth(lessThanSlashToken);
        this.lessThanSlashToken = lessThanSlashToken;
        this.AdjustFlagsAndWidth(name);
        this.name = name;
        this.AdjustFlagsAndWidth(greaterThanToken);
        this.greaterThanToken = greaterThanToken;
    }


    internal XmlElementEndTagSyntax(SyntaxKind kind, SyntaxToken lessThanSlashToken, XmlNameSyntax name, SyntaxToken greaterThanToken, SyntaxFactoryContext context)
        : base(kind)
    {
        this.SetFactoryContext(context);
        this.SlotCount = 3;
        this.AdjustFlagsAndWidth(lessThanSlashToken);
        this.lessThanSlashToken = lessThanSlashToken;
        this.AdjustFlagsAndWidth(name);
        this.name = name;
        this.AdjustFlagsAndWidth(greaterThanToken);
        this.greaterThanToken = greaterThanToken;
    }


    internal XmlElementEndTagSyntax(SyntaxKind kind, SyntaxToken lessThanSlashToken, XmlNameSyntax name, SyntaxToken greaterThanToken)
        : base(kind)
    {
        this.SlotCount = 3;
        this.AdjustFlagsAndWidth(lessThanSlashToken);
        this.lessThanSlashToken = lessThanSlashToken;
        this.AdjustFlagsAndWidth(name);
        this.name = name;
        this.AdjustFlagsAndWidth(greaterThanToken);
        this.greaterThanToken = greaterThanToken;
    }

    public SyntaxToken LessThanSlashToken { get { return this.lessThanSlashToken; } }
    public XmlNameSyntax Name { get { return this.name; } }
    public SyntaxToken GreaterThanToken { get { return this.greaterThanToken; } }

    internal override GreenNode GetSlot(int index)
    {
        switch (index)
        {
            case 0: return this.lessThanSlashToken;
            case 1: return this.name;
            case 2: return this.greaterThanToken;
            default: return null;
        }
    }

    internal override SyntaxNode CreateRed(SyntaxNode parent, int position)
    {
      return new Xml.Syntax.XmlElementEndTagSyntax(this, parent, position);
    }

    public override TResult Accept<TResult>(XmlSyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitXmlElementEndTag(this);
    }

    public override void Accept(XmlSyntaxVisitor visitor)
    {
        visitor.VisitXmlElementEndTag(this);
    }

    public XmlElementEndTagSyntax Update(SyntaxToken lessThanSlashToken, XmlNameSyntax name, SyntaxToken greaterThanToken)
    {
        if (lessThanSlashToken != this.LessThanSlashToken || name != this.Name || greaterThanToken != this.GreaterThanToken)
        {
            var newNode = SyntaxFactory.XmlElementEndTag(lessThanSlashToken, name, greaterThanToken);
            var diags = this.GetDiagnostics();
            if (diags != null && diags.Length > 0)
               newNode = newNode.WithDiagnosticsGreen(diags);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               newNode = newNode.WithAnnotationsGreen(annotations);
            return newNode;
        }

        return this;
    }

    internal override GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics)
    {
         return new XmlElementEndTagSyntax(this.Kind, this.lessThanSlashToken, this.name, this.greaterThanToken, diagnostics, GetAnnotations());
    }

    internal override GreenNode SetAnnotations(SyntaxAnnotation[] annotations)
    {
         return new XmlElementEndTagSyntax(this.Kind, this.lessThanSlashToken, this.name, this.greaterThanToken, GetDiagnostics(), annotations);
    }

    internal XmlElementEndTagSyntax(ObjectReader reader)
        : base(reader)
    {
      this.SlotCount = 3;
      var lessThanSlashToken = (SyntaxToken)reader.ReadValue();
      if (lessThanSlashToken != null)
      {
         AdjustFlagsAndWidth(lessThanSlashToken);
         this.lessThanSlashToken = lessThanSlashToken;
      }
      var name = (XmlNameSyntax)reader.ReadValue();
      if (name != null)
      {
         AdjustFlagsAndWidth(name);
         this.name = name;
      }
      var greaterThanToken = (SyntaxToken)reader.ReadValue();
      if (greaterThanToken != null)
      {
         AdjustFlagsAndWidth(greaterThanToken);
         this.greaterThanToken = greaterThanToken;
      }
    }

    internal override void WriteTo(ObjectWriter writer)
    {
      base.WriteTo(writer);
      writer.WriteValue(this.lessThanSlashToken);
      writer.WriteValue(this.name);
      writer.WriteValue(this.greaterThanToken);
    }

    static XmlElementEndTagSyntax()
    {
       ObjectBinder.RegisterTypeReader(typeof(XmlElementEndTagSyntax), r => new XmlElementEndTagSyntax(r));
    }
  }

  internal sealed partial class XmlEmptyElementSyntax : XmlNodeSyntax
  {
    internal readonly SyntaxToken lessThanToken;
    internal readonly XmlNameSyntax name;
    internal readonly GreenNode attributes;
    internal readonly SyntaxToken slashGreaterThanToken;

    internal XmlEmptyElementSyntax(SyntaxKind kind, SyntaxToken lessThanToken, XmlNameSyntax name, GreenNode attributes, SyntaxToken slashGreaterThanToken, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
        : base(kind, diagnostics, annotations)
    {
        this.SlotCount = 4;
        this.AdjustFlagsAndWidth(lessThanToken);
        this.lessThanToken = lessThanToken;
        this.AdjustFlagsAndWidth(name);
        this.name = name;
        if (attributes != null)
        {
            this.AdjustFlagsAndWidth(attributes);
            this.attributes = attributes;
        }
        this.AdjustFlagsAndWidth(slashGreaterThanToken);
        this.slashGreaterThanToken = slashGreaterThanToken;
    }


    internal XmlEmptyElementSyntax(SyntaxKind kind, SyntaxToken lessThanToken, XmlNameSyntax name, GreenNode attributes, SyntaxToken slashGreaterThanToken, SyntaxFactoryContext context)
        : base(kind)
    {
        this.SetFactoryContext(context);
        this.SlotCount = 4;
        this.AdjustFlagsAndWidth(lessThanToken);
        this.lessThanToken = lessThanToken;
        this.AdjustFlagsAndWidth(name);
        this.name = name;
        if (attributes != null)
        {
            this.AdjustFlagsAndWidth(attributes);
            this.attributes = attributes;
        }
        this.AdjustFlagsAndWidth(slashGreaterThanToken);
        this.slashGreaterThanToken = slashGreaterThanToken;
    }


    internal XmlEmptyElementSyntax(SyntaxKind kind, SyntaxToken lessThanToken, XmlNameSyntax name, GreenNode attributes, SyntaxToken slashGreaterThanToken)
        : base(kind)
    {
        this.SlotCount = 4;
        this.AdjustFlagsAndWidth(lessThanToken);
        this.lessThanToken = lessThanToken;
        this.AdjustFlagsAndWidth(name);
        this.name = name;
        if (attributes != null)
        {
            this.AdjustFlagsAndWidth(attributes);
            this.attributes = attributes;
        }
        this.AdjustFlagsAndWidth(slashGreaterThanToken);
        this.slashGreaterThanToken = slashGreaterThanToken;
    }

    public SyntaxToken LessThanToken { get { return this.lessThanToken; } }
    public XmlNameSyntax Name { get { return this.name; } }
    public Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<XmlAttributeSyntax> Attributes { get { return new Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<XmlAttributeSyntax>(this.attributes); } }
    public SyntaxToken SlashGreaterThanToken { get { return this.slashGreaterThanToken; } }

    internal override GreenNode GetSlot(int index)
    {
        switch (index)
        {
            case 0: return this.lessThanToken;
            case 1: return this.name;
            case 2: return this.attributes;
            case 3: return this.slashGreaterThanToken;
            default: return null;
        }
    }

    internal override SyntaxNode CreateRed(SyntaxNode parent, int position)
    {
      return new Xml.Syntax.XmlEmptyElementSyntax(this, parent, position);
    }

    public override TResult Accept<TResult>(XmlSyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitXmlEmptyElement(this);
    }

    public override void Accept(XmlSyntaxVisitor visitor)
    {
        visitor.VisitXmlEmptyElement(this);
    }

    public XmlEmptyElementSyntax Update(SyntaxToken lessThanToken, XmlNameSyntax name, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<XmlAttributeSyntax> attributes, SyntaxToken slashGreaterThanToken)
    {
        if (lessThanToken != this.LessThanToken || name != this.Name || attributes != this.Attributes || slashGreaterThanToken != this.SlashGreaterThanToken)
        {
            var newNode = SyntaxFactory.XmlEmptyElement(lessThanToken, name, attributes, slashGreaterThanToken);
            var diags = this.GetDiagnostics();
            if (diags != null && diags.Length > 0)
               newNode = newNode.WithDiagnosticsGreen(diags);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               newNode = newNode.WithAnnotationsGreen(annotations);
            return newNode;
        }

        return this;
    }

    internal override GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics)
    {
         return new XmlEmptyElementSyntax(this.Kind, this.lessThanToken, this.name, this.attributes, this.slashGreaterThanToken, diagnostics, GetAnnotations());
    }

    internal override GreenNode SetAnnotations(SyntaxAnnotation[] annotations)
    {
         return new XmlEmptyElementSyntax(this.Kind, this.lessThanToken, this.name, this.attributes, this.slashGreaterThanToken, GetDiagnostics(), annotations);
    }

    internal XmlEmptyElementSyntax(ObjectReader reader)
        : base(reader)
    {
      this.SlotCount = 4;
      var lessThanToken = (SyntaxToken)reader.ReadValue();
      if (lessThanToken != null)
      {
         AdjustFlagsAndWidth(lessThanToken);
         this.lessThanToken = lessThanToken;
      }
      var name = (XmlNameSyntax)reader.ReadValue();
      if (name != null)
      {
         AdjustFlagsAndWidth(name);
         this.name = name;
      }
      var attributes = (GreenNode)reader.ReadValue();
      if (attributes != null)
      {
         AdjustFlagsAndWidth(attributes);
         this.attributes = attributes;
      }
      var slashGreaterThanToken = (SyntaxToken)reader.ReadValue();
      if (slashGreaterThanToken != null)
      {
         AdjustFlagsAndWidth(slashGreaterThanToken);
         this.slashGreaterThanToken = slashGreaterThanToken;
      }
    }

    internal override void WriteTo(ObjectWriter writer)
    {
      base.WriteTo(writer);
      writer.WriteValue(this.lessThanToken);
      writer.WriteValue(this.name);
      writer.WriteValue(this.attributes);
      writer.WriteValue(this.slashGreaterThanToken);
    }

    static XmlEmptyElementSyntax()
    {
       ObjectBinder.RegisterTypeReader(typeof(XmlEmptyElementSyntax), r => new XmlEmptyElementSyntax(r));
    }
  }

  internal sealed partial class XmlNameSyntax : XmlSyntaxNode
  {
    internal readonly XmlPrefixSyntax prefix;
    internal readonly SyntaxToken localName;

    internal XmlNameSyntax(SyntaxKind kind, XmlPrefixSyntax prefix, SyntaxToken localName, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
        : base(kind, diagnostics, annotations)
    {
        this.SlotCount = 2;
        if (prefix != null)
        {
            this.AdjustFlagsAndWidth(prefix);
            this.prefix = prefix;
        }
        this.AdjustFlagsAndWidth(localName);
        this.localName = localName;
    }


    internal XmlNameSyntax(SyntaxKind kind, XmlPrefixSyntax prefix, SyntaxToken localName, SyntaxFactoryContext context)
        : base(kind)
    {
        this.SetFactoryContext(context);
        this.SlotCount = 2;
        if (prefix != null)
        {
            this.AdjustFlagsAndWidth(prefix);
            this.prefix = prefix;
        }
        this.AdjustFlagsAndWidth(localName);
        this.localName = localName;
    }


    internal XmlNameSyntax(SyntaxKind kind, XmlPrefixSyntax prefix, SyntaxToken localName)
        : base(kind)
    {
        this.SlotCount = 2;
        if (prefix != null)
        {
            this.AdjustFlagsAndWidth(prefix);
            this.prefix = prefix;
        }
        this.AdjustFlagsAndWidth(localName);
        this.localName = localName;
    }

    public XmlPrefixSyntax Prefix { get { return this.prefix; } }
    public SyntaxToken LocalName { get { return this.localName; } }

    internal override GreenNode GetSlot(int index)
    {
        switch (index)
        {
            case 0: return this.prefix;
            case 1: return this.localName;
            default: return null;
        }
    }

    internal override SyntaxNode CreateRed(SyntaxNode parent, int position)
    {
      return new Xml.Syntax.XmlNameSyntax(this, parent, position);
    }

    public override TResult Accept<TResult>(XmlSyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitXmlName(this);
    }

    public override void Accept(XmlSyntaxVisitor visitor)
    {
        visitor.VisitXmlName(this);
    }

    public XmlNameSyntax Update(XmlPrefixSyntax prefix, SyntaxToken localName)
    {
        if (prefix != this.Prefix || localName != this.LocalName)
        {
            var newNode = SyntaxFactory.XmlName(prefix, localName);
            var diags = this.GetDiagnostics();
            if (diags != null && diags.Length > 0)
               newNode = newNode.WithDiagnosticsGreen(diags);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               newNode = newNode.WithAnnotationsGreen(annotations);
            return newNode;
        }

        return this;
    }

    internal override GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics)
    {
         return new XmlNameSyntax(this.Kind, this.prefix, this.localName, diagnostics, GetAnnotations());
    }

    internal override GreenNode SetAnnotations(SyntaxAnnotation[] annotations)
    {
         return new XmlNameSyntax(this.Kind, this.prefix, this.localName, GetDiagnostics(), annotations);
    }

    internal XmlNameSyntax(ObjectReader reader)
        : base(reader)
    {
      this.SlotCount = 2;
      var prefix = (XmlPrefixSyntax)reader.ReadValue();
      if (prefix != null)
      {
         AdjustFlagsAndWidth(prefix);
         this.prefix = prefix;
      }
      var localName = (SyntaxToken)reader.ReadValue();
      if (localName != null)
      {
         AdjustFlagsAndWidth(localName);
         this.localName = localName;
      }
    }

    internal override void WriteTo(ObjectWriter writer)
    {
      base.WriteTo(writer);
      writer.WriteValue(this.prefix);
      writer.WriteValue(this.localName);
    }

    static XmlNameSyntax()
    {
       ObjectBinder.RegisterTypeReader(typeof(XmlNameSyntax), r => new XmlNameSyntax(r));
    }
  }

  internal sealed partial class XmlPrefixSyntax : XmlSyntaxNode
  {
    internal readonly SyntaxToken prefix;
    internal readonly SyntaxToken colonToken;

    internal XmlPrefixSyntax(SyntaxKind kind, SyntaxToken prefix, SyntaxToken colonToken, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
        : base(kind, diagnostics, annotations)
    {
        this.SlotCount = 2;
        this.AdjustFlagsAndWidth(prefix);
        this.prefix = prefix;
        this.AdjustFlagsAndWidth(colonToken);
        this.colonToken = colonToken;
    }


    internal XmlPrefixSyntax(SyntaxKind kind, SyntaxToken prefix, SyntaxToken colonToken, SyntaxFactoryContext context)
        : base(kind)
    {
        this.SetFactoryContext(context);
        this.SlotCount = 2;
        this.AdjustFlagsAndWidth(prefix);
        this.prefix = prefix;
        this.AdjustFlagsAndWidth(colonToken);
        this.colonToken = colonToken;
    }


    internal XmlPrefixSyntax(SyntaxKind kind, SyntaxToken prefix, SyntaxToken colonToken)
        : base(kind)
    {
        this.SlotCount = 2;
        this.AdjustFlagsAndWidth(prefix);
        this.prefix = prefix;
        this.AdjustFlagsAndWidth(colonToken);
        this.colonToken = colonToken;
    }

    public SyntaxToken Prefix { get { return this.prefix; } }
    public SyntaxToken ColonToken { get { return this.colonToken; } }

    internal override GreenNode GetSlot(int index)
    {
        switch (index)
        {
            case 0: return this.prefix;
            case 1: return this.colonToken;
            default: return null;
        }
    }

    internal override SyntaxNode CreateRed(SyntaxNode parent, int position)
    {
      return new Xml.Syntax.XmlPrefixSyntax(this, parent, position);
    }

    public override TResult Accept<TResult>(XmlSyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitXmlPrefix(this);
    }

    public override void Accept(XmlSyntaxVisitor visitor)
    {
        visitor.VisitXmlPrefix(this);
    }

    public XmlPrefixSyntax Update(SyntaxToken prefix, SyntaxToken colonToken)
    {
        if (prefix != this.Prefix || colonToken != this.ColonToken)
        {
            var newNode = SyntaxFactory.XmlPrefix(prefix, colonToken);
            var diags = this.GetDiagnostics();
            if (diags != null && diags.Length > 0)
               newNode = newNode.WithDiagnosticsGreen(diags);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               newNode = newNode.WithAnnotationsGreen(annotations);
            return newNode;
        }

        return this;
    }

    internal override GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics)
    {
         return new XmlPrefixSyntax(this.Kind, this.prefix, this.colonToken, diagnostics, GetAnnotations());
    }

    internal override GreenNode SetAnnotations(SyntaxAnnotation[] annotations)
    {
         return new XmlPrefixSyntax(this.Kind, this.prefix, this.colonToken, GetDiagnostics(), annotations);
    }

    internal XmlPrefixSyntax(ObjectReader reader)
        : base(reader)
    {
      this.SlotCount = 2;
      var prefix = (SyntaxToken)reader.ReadValue();
      if (prefix != null)
      {
         AdjustFlagsAndWidth(prefix);
         this.prefix = prefix;
      }
      var colonToken = (SyntaxToken)reader.ReadValue();
      if (colonToken != null)
      {
         AdjustFlagsAndWidth(colonToken);
         this.colonToken = colonToken;
      }
    }

    internal override void WriteTo(ObjectWriter writer)
    {
      base.WriteTo(writer);
      writer.WriteValue(this.prefix);
      writer.WriteValue(this.colonToken);
    }

    static XmlPrefixSyntax()
    {
       ObjectBinder.RegisterTypeReader(typeof(XmlPrefixSyntax), r => new XmlPrefixSyntax(r));
    }
  }

  internal abstract partial class XmlAttributeSyntax : XmlSyntaxNode
  {
    internal XmlAttributeSyntax(SyntaxKind kind, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
      : base(kind, diagnostics, annotations)
    {
    }
    internal XmlAttributeSyntax(SyntaxKind kind)
      : base(kind)
    {
    }

    protected XmlAttributeSyntax(ObjectReader reader)
       : base(reader)
    {
    }

    public abstract XmlNameSyntax Name { get; }

    public abstract SyntaxToken EqualsToken { get; }

    public abstract SyntaxToken StartQuoteToken { get; }

    public abstract SyntaxToken EndQuoteToken { get; }
  }

  internal sealed partial class XmlTextAttributeSyntax : XmlAttributeSyntax
  {
    internal readonly XmlNameSyntax name;
    internal readonly SyntaxToken equalsToken;
    internal readonly SyntaxToken startQuoteToken;
    internal readonly GreenNode textTokens;
    internal readonly SyntaxToken endQuoteToken;

    internal XmlTextAttributeSyntax(SyntaxKind kind, XmlNameSyntax name, SyntaxToken equalsToken, SyntaxToken startQuoteToken, GreenNode textTokens, SyntaxToken endQuoteToken, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
        : base(kind, diagnostics, annotations)
    {
        this.SlotCount = 5;
        this.AdjustFlagsAndWidth(name);
        this.name = name;
        this.AdjustFlagsAndWidth(equalsToken);
        this.equalsToken = equalsToken;
        this.AdjustFlagsAndWidth(startQuoteToken);
        this.startQuoteToken = startQuoteToken;
        if (textTokens != null)
        {
            this.AdjustFlagsAndWidth(textTokens);
            this.textTokens = textTokens;
        }
        this.AdjustFlagsAndWidth(endQuoteToken);
        this.endQuoteToken = endQuoteToken;
    }


    internal XmlTextAttributeSyntax(SyntaxKind kind, XmlNameSyntax name, SyntaxToken equalsToken, SyntaxToken startQuoteToken, GreenNode textTokens, SyntaxToken endQuoteToken, SyntaxFactoryContext context)
        : base(kind)
    {
        this.SetFactoryContext(context);
        this.SlotCount = 5;
        this.AdjustFlagsAndWidth(name);
        this.name = name;
        this.AdjustFlagsAndWidth(equalsToken);
        this.equalsToken = equalsToken;
        this.AdjustFlagsAndWidth(startQuoteToken);
        this.startQuoteToken = startQuoteToken;
        if (textTokens != null)
        {
            this.AdjustFlagsAndWidth(textTokens);
            this.textTokens = textTokens;
        }
        this.AdjustFlagsAndWidth(endQuoteToken);
        this.endQuoteToken = endQuoteToken;
    }


    internal XmlTextAttributeSyntax(SyntaxKind kind, XmlNameSyntax name, SyntaxToken equalsToken, SyntaxToken startQuoteToken, GreenNode textTokens, SyntaxToken endQuoteToken)
        : base(kind)
    {
        this.SlotCount = 5;
        this.AdjustFlagsAndWidth(name);
        this.name = name;
        this.AdjustFlagsAndWidth(equalsToken);
        this.equalsToken = equalsToken;
        this.AdjustFlagsAndWidth(startQuoteToken);
        this.startQuoteToken = startQuoteToken;
        if (textTokens != null)
        {
            this.AdjustFlagsAndWidth(textTokens);
            this.textTokens = textTokens;
        }
        this.AdjustFlagsAndWidth(endQuoteToken);
        this.endQuoteToken = endQuoteToken;
    }

    public override XmlNameSyntax Name { get { return this.name; } }
    public override SyntaxToken EqualsToken { get { return this.equalsToken; } }
    public override SyntaxToken StartQuoteToken { get { return this.startQuoteToken; } }
    public Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<SyntaxToken> TextTokens { get { return new Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<SyntaxToken>(this.textTokens); } }
    public override SyntaxToken EndQuoteToken { get { return this.endQuoteToken; } }

    internal override GreenNode GetSlot(int index)
    {
        switch (index)
        {
            case 0: return this.name;
            case 1: return this.equalsToken;
            case 2: return this.startQuoteToken;
            case 3: return this.textTokens;
            case 4: return this.endQuoteToken;
            default: return null;
        }
    }

    internal override SyntaxNode CreateRed(SyntaxNode parent, int position)
    {
      return new Xml.Syntax.XmlTextAttributeSyntax(this, parent, position);
    }

    public override TResult Accept<TResult>(XmlSyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitXmlTextAttribute(this);
    }

    public override void Accept(XmlSyntaxVisitor visitor)
    {
        visitor.VisitXmlTextAttribute(this);
    }

    public XmlTextAttributeSyntax Update(XmlNameSyntax name, SyntaxToken equalsToken, SyntaxToken startQuoteToken, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<SyntaxToken> textTokens, SyntaxToken endQuoteToken)
    {
        if (name != this.Name || equalsToken != this.EqualsToken || startQuoteToken != this.StartQuoteToken || textTokens != this.TextTokens || endQuoteToken != this.EndQuoteToken)
        {
            var newNode = SyntaxFactory.XmlTextAttribute(name, equalsToken, startQuoteToken, textTokens, endQuoteToken);
            var diags = this.GetDiagnostics();
            if (diags != null && diags.Length > 0)
               newNode = newNode.WithDiagnosticsGreen(diags);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               newNode = newNode.WithAnnotationsGreen(annotations);
            return newNode;
        }

        return this;
    }

    internal override GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics)
    {
         return new XmlTextAttributeSyntax(this.Kind, this.name, this.equalsToken, this.startQuoteToken, this.textTokens, this.endQuoteToken, diagnostics, GetAnnotations());
    }

    internal override GreenNode SetAnnotations(SyntaxAnnotation[] annotations)
    {
         return new XmlTextAttributeSyntax(this.Kind, this.name, this.equalsToken, this.startQuoteToken, this.textTokens, this.endQuoteToken, GetDiagnostics(), annotations);
    }

    internal XmlTextAttributeSyntax(ObjectReader reader)
        : base(reader)
    {
      this.SlotCount = 5;
      var name = (XmlNameSyntax)reader.ReadValue();
      if (name != null)
      {
         AdjustFlagsAndWidth(name);
         this.name = name;
      }
      var equalsToken = (SyntaxToken)reader.ReadValue();
      if (equalsToken != null)
      {
         AdjustFlagsAndWidth(equalsToken);
         this.equalsToken = equalsToken;
      }
      var startQuoteToken = (SyntaxToken)reader.ReadValue();
      if (startQuoteToken != null)
      {
         AdjustFlagsAndWidth(startQuoteToken);
         this.startQuoteToken = startQuoteToken;
      }
      var textTokens = (GreenNode)reader.ReadValue();
      if (textTokens != null)
      {
         AdjustFlagsAndWidth(textTokens);
         this.textTokens = textTokens;
      }
      var endQuoteToken = (SyntaxToken)reader.ReadValue();
      if (endQuoteToken != null)
      {
         AdjustFlagsAndWidth(endQuoteToken);
         this.endQuoteToken = endQuoteToken;
      }
    }

    internal override void WriteTo(ObjectWriter writer)
    {
      base.WriteTo(writer);
      writer.WriteValue(this.name);
      writer.WriteValue(this.equalsToken);
      writer.WriteValue(this.startQuoteToken);
      writer.WriteValue(this.textTokens);
      writer.WriteValue(this.endQuoteToken);
    }

    static XmlTextAttributeSyntax()
    {
       ObjectBinder.RegisterTypeReader(typeof(XmlTextAttributeSyntax), r => new XmlTextAttributeSyntax(r));
    }
  }

  internal sealed partial class XmlNameAttributeSyntax : XmlAttributeSyntax
  {
    internal readonly XmlNameSyntax name;
    internal readonly SyntaxToken equalsToken;
    internal readonly SyntaxToken startQuoteToken;
    internal readonly IdentifierNameSyntax identifier;
    internal readonly SyntaxToken endQuoteToken;

    internal XmlNameAttributeSyntax(SyntaxKind kind, XmlNameSyntax name, SyntaxToken equalsToken, SyntaxToken startQuoteToken, IdentifierNameSyntax identifier, SyntaxToken endQuoteToken, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
        : base(kind, diagnostics, annotations)
    {
        this.SlotCount = 5;
        this.AdjustFlagsAndWidth(name);
        this.name = name;
        this.AdjustFlagsAndWidth(equalsToken);
        this.equalsToken = equalsToken;
        this.AdjustFlagsAndWidth(startQuoteToken);
        this.startQuoteToken = startQuoteToken;
        this.AdjustFlagsAndWidth(identifier);
        this.identifier = identifier;
        this.AdjustFlagsAndWidth(endQuoteToken);
        this.endQuoteToken = endQuoteToken;
    }


    internal XmlNameAttributeSyntax(SyntaxKind kind, XmlNameSyntax name, SyntaxToken equalsToken, SyntaxToken startQuoteToken, IdentifierNameSyntax identifier, SyntaxToken endQuoteToken, SyntaxFactoryContext context)
        : base(kind)
    {
        this.SetFactoryContext(context);
        this.SlotCount = 5;
        this.AdjustFlagsAndWidth(name);
        this.name = name;
        this.AdjustFlagsAndWidth(equalsToken);
        this.equalsToken = equalsToken;
        this.AdjustFlagsAndWidth(startQuoteToken);
        this.startQuoteToken = startQuoteToken;
        this.AdjustFlagsAndWidth(identifier);
        this.identifier = identifier;
        this.AdjustFlagsAndWidth(endQuoteToken);
        this.endQuoteToken = endQuoteToken;
    }


    internal XmlNameAttributeSyntax(SyntaxKind kind, XmlNameSyntax name, SyntaxToken equalsToken, SyntaxToken startQuoteToken, IdentifierNameSyntax identifier, SyntaxToken endQuoteToken)
        : base(kind)
    {
        this.SlotCount = 5;
        this.AdjustFlagsAndWidth(name);
        this.name = name;
        this.AdjustFlagsAndWidth(equalsToken);
        this.equalsToken = equalsToken;
        this.AdjustFlagsAndWidth(startQuoteToken);
        this.startQuoteToken = startQuoteToken;
        this.AdjustFlagsAndWidth(identifier);
        this.identifier = identifier;
        this.AdjustFlagsAndWidth(endQuoteToken);
        this.endQuoteToken = endQuoteToken;
    }

    public override XmlNameSyntax Name { get { return this.name; } }
    public override SyntaxToken EqualsToken { get { return this.equalsToken; } }
    public override SyntaxToken StartQuoteToken { get { return this.startQuoteToken; } }
    public IdentifierNameSyntax Identifier { get { return this.identifier; } }
    public override SyntaxToken EndQuoteToken { get { return this.endQuoteToken; } }

    internal override GreenNode GetSlot(int index)
    {
        switch (index)
        {
            case 0: return this.name;
            case 1: return this.equalsToken;
            case 2: return this.startQuoteToken;
            case 3: return this.identifier;
            case 4: return this.endQuoteToken;
            default: return null;
        }
    }

    internal override SyntaxNode CreateRed(SyntaxNode parent, int position)
    {
      return new Xml.Syntax.XmlNameAttributeSyntax(this, parent, position);
    }

    public override TResult Accept<TResult>(XmlSyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitXmlNameAttribute(this);
    }

    public override void Accept(XmlSyntaxVisitor visitor)
    {
        visitor.VisitXmlNameAttribute(this);
    }

    public XmlNameAttributeSyntax Update(XmlNameSyntax name, SyntaxToken equalsToken, SyntaxToken startQuoteToken, IdentifierNameSyntax identifier, SyntaxToken endQuoteToken)
    {
        if (name != this.Name || equalsToken != this.EqualsToken || startQuoteToken != this.StartQuoteToken || identifier != this.Identifier || endQuoteToken != this.EndQuoteToken)
        {
            var newNode = SyntaxFactory.XmlNameAttribute(name, equalsToken, startQuoteToken, identifier, endQuoteToken);
            var diags = this.GetDiagnostics();
            if (diags != null && diags.Length > 0)
               newNode = newNode.WithDiagnosticsGreen(diags);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               newNode = newNode.WithAnnotationsGreen(annotations);
            return newNode;
        }

        return this;
    }

    internal override GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics)
    {
         return new XmlNameAttributeSyntax(this.Kind, this.name, this.equalsToken, this.startQuoteToken, this.identifier, this.endQuoteToken, diagnostics, GetAnnotations());
    }

    internal override GreenNode SetAnnotations(SyntaxAnnotation[] annotations)
    {
         return new XmlNameAttributeSyntax(this.Kind, this.name, this.equalsToken, this.startQuoteToken, this.identifier, this.endQuoteToken, GetDiagnostics(), annotations);
    }

    internal XmlNameAttributeSyntax(ObjectReader reader)
        : base(reader)
    {
      this.SlotCount = 5;
      var name = (XmlNameSyntax)reader.ReadValue();
      if (name != null)
      {
         AdjustFlagsAndWidth(name);
         this.name = name;
      }
      var equalsToken = (SyntaxToken)reader.ReadValue();
      if (equalsToken != null)
      {
         AdjustFlagsAndWidth(equalsToken);
         this.equalsToken = equalsToken;
      }
      var startQuoteToken = (SyntaxToken)reader.ReadValue();
      if (startQuoteToken != null)
      {
         AdjustFlagsAndWidth(startQuoteToken);
         this.startQuoteToken = startQuoteToken;
      }
      var identifier = (IdentifierNameSyntax)reader.ReadValue();
      if (identifier != null)
      {
         AdjustFlagsAndWidth(identifier);
         this.identifier = identifier;
      }
      var endQuoteToken = (SyntaxToken)reader.ReadValue();
      if (endQuoteToken != null)
      {
         AdjustFlagsAndWidth(endQuoteToken);
         this.endQuoteToken = endQuoteToken;
      }
    }

    internal override void WriteTo(ObjectWriter writer)
    {
      base.WriteTo(writer);
      writer.WriteValue(this.name);
      writer.WriteValue(this.equalsToken);
      writer.WriteValue(this.startQuoteToken);
      writer.WriteValue(this.identifier);
      writer.WriteValue(this.endQuoteToken);
    }

    static XmlNameAttributeSyntax()
    {
       ObjectBinder.RegisterTypeReader(typeof(XmlNameAttributeSyntax), r => new XmlNameAttributeSyntax(r));
    }
  }

  internal sealed partial class XmlTextSyntax : XmlNodeSyntax
  {
    internal readonly GreenNode textTokens;

    internal XmlTextSyntax(SyntaxKind kind, GreenNode textTokens, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
        : base(kind, diagnostics, annotations)
    {
        this.SlotCount = 1;
        if (textTokens != null)
        {
            this.AdjustFlagsAndWidth(textTokens);
            this.textTokens = textTokens;
        }
    }


    internal XmlTextSyntax(SyntaxKind kind, GreenNode textTokens, SyntaxFactoryContext context)
        : base(kind)
    {
        this.SetFactoryContext(context);
        this.SlotCount = 1;
        if (textTokens != null)
        {
            this.AdjustFlagsAndWidth(textTokens);
            this.textTokens = textTokens;
        }
    }


    internal XmlTextSyntax(SyntaxKind kind, GreenNode textTokens)
        : base(kind)
    {
        this.SlotCount = 1;
        if (textTokens != null)
        {
            this.AdjustFlagsAndWidth(textTokens);
            this.textTokens = textTokens;
        }
    }

    public Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<SyntaxToken> TextTokens { get { return new Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<SyntaxToken>(this.textTokens); } }

    internal override GreenNode GetSlot(int index)
    {
        switch (index)
        {
            case 0: return this.textTokens;
            default: return null;
        }
    }

    internal override SyntaxNode CreateRed(SyntaxNode parent, int position)
    {
      return new Xml.Syntax.XmlTextSyntax(this, parent, position);
    }

    public override TResult Accept<TResult>(XmlSyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitXmlText(this);
    }

    public override void Accept(XmlSyntaxVisitor visitor)
    {
        visitor.VisitXmlText(this);
    }

    public XmlTextSyntax Update(Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<SyntaxToken> textTokens)
    {
        if (textTokens != this.TextTokens)
        {
            var newNode = SyntaxFactory.XmlText(textTokens);
            var diags = this.GetDiagnostics();
            if (diags != null && diags.Length > 0)
               newNode = newNode.WithDiagnosticsGreen(diags);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               newNode = newNode.WithAnnotationsGreen(annotations);
            return newNode;
        }

        return this;
    }

    internal override GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics)
    {
         return new XmlTextSyntax(this.Kind, this.textTokens, diagnostics, GetAnnotations());
    }

    internal override GreenNode SetAnnotations(SyntaxAnnotation[] annotations)
    {
         return new XmlTextSyntax(this.Kind, this.textTokens, GetDiagnostics(), annotations);
    }

    internal XmlTextSyntax(ObjectReader reader)
        : base(reader)
    {
      this.SlotCount = 1;
      var textTokens = (GreenNode)reader.ReadValue();
      if (textTokens != null)
      {
         AdjustFlagsAndWidth(textTokens);
         this.textTokens = textTokens;
      }
    }

    internal override void WriteTo(ObjectWriter writer)
    {
      base.WriteTo(writer);
      writer.WriteValue(this.textTokens);
    }

    static XmlTextSyntax()
    {
       ObjectBinder.RegisterTypeReader(typeof(XmlTextSyntax), r => new XmlTextSyntax(r));
    }
  }

  internal sealed partial class XmlCDataSectionSyntax : XmlNodeSyntax
  {
    internal readonly SyntaxToken startCDataToken;
    internal readonly GreenNode textTokens;
    internal readonly SyntaxToken endCDataToken;

    internal XmlCDataSectionSyntax(SyntaxKind kind, SyntaxToken startCDataToken, GreenNode textTokens, SyntaxToken endCDataToken, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
        : base(kind, diagnostics, annotations)
    {
        this.SlotCount = 3;
        this.AdjustFlagsAndWidth(startCDataToken);
        this.startCDataToken = startCDataToken;
        if (textTokens != null)
        {
            this.AdjustFlagsAndWidth(textTokens);
            this.textTokens = textTokens;
        }
        this.AdjustFlagsAndWidth(endCDataToken);
        this.endCDataToken = endCDataToken;
    }


    internal XmlCDataSectionSyntax(SyntaxKind kind, SyntaxToken startCDataToken, GreenNode textTokens, SyntaxToken endCDataToken, SyntaxFactoryContext context)
        : base(kind)
    {
        this.SetFactoryContext(context);
        this.SlotCount = 3;
        this.AdjustFlagsAndWidth(startCDataToken);
        this.startCDataToken = startCDataToken;
        if (textTokens != null)
        {
            this.AdjustFlagsAndWidth(textTokens);
            this.textTokens = textTokens;
        }
        this.AdjustFlagsAndWidth(endCDataToken);
        this.endCDataToken = endCDataToken;
    }


    internal XmlCDataSectionSyntax(SyntaxKind kind, SyntaxToken startCDataToken, GreenNode textTokens, SyntaxToken endCDataToken)
        : base(kind)
    {
        this.SlotCount = 3;
        this.AdjustFlagsAndWidth(startCDataToken);
        this.startCDataToken = startCDataToken;
        if (textTokens != null)
        {
            this.AdjustFlagsAndWidth(textTokens);
            this.textTokens = textTokens;
        }
        this.AdjustFlagsAndWidth(endCDataToken);
        this.endCDataToken = endCDataToken;
    }

    public SyntaxToken StartCDataToken { get { return this.startCDataToken; } }
    public Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<SyntaxToken> TextTokens { get { return new Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<SyntaxToken>(this.textTokens); } }
    public SyntaxToken EndCDataToken { get { return this.endCDataToken; } }

    internal override GreenNode GetSlot(int index)
    {
        switch (index)
        {
            case 0: return this.startCDataToken;
            case 1: return this.textTokens;
            case 2: return this.endCDataToken;
            default: return null;
        }
    }

    internal override SyntaxNode CreateRed(SyntaxNode parent, int position)
    {
      return new Xml.Syntax.XmlCDataSectionSyntax(this, parent, position);
    }

    public override TResult Accept<TResult>(XmlSyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitXmlCDataSection(this);
    }

    public override void Accept(XmlSyntaxVisitor visitor)
    {
        visitor.VisitXmlCDataSection(this);
    }

    public XmlCDataSectionSyntax Update(SyntaxToken startCDataToken, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<SyntaxToken> textTokens, SyntaxToken endCDataToken)
    {
        if (startCDataToken != this.StartCDataToken || textTokens != this.TextTokens || endCDataToken != this.EndCDataToken)
        {
            var newNode = SyntaxFactory.XmlCDataSection(startCDataToken, textTokens, endCDataToken);
            var diags = this.GetDiagnostics();
            if (diags != null && diags.Length > 0)
               newNode = newNode.WithDiagnosticsGreen(diags);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               newNode = newNode.WithAnnotationsGreen(annotations);
            return newNode;
        }

        return this;
    }

    internal override GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics)
    {
         return new XmlCDataSectionSyntax(this.Kind, this.startCDataToken, this.textTokens, this.endCDataToken, diagnostics, GetAnnotations());
    }

    internal override GreenNode SetAnnotations(SyntaxAnnotation[] annotations)
    {
         return new XmlCDataSectionSyntax(this.Kind, this.startCDataToken, this.textTokens, this.endCDataToken, GetDiagnostics(), annotations);
    }

    internal XmlCDataSectionSyntax(ObjectReader reader)
        : base(reader)
    {
      this.SlotCount = 3;
      var startCDataToken = (SyntaxToken)reader.ReadValue();
      if (startCDataToken != null)
      {
         AdjustFlagsAndWidth(startCDataToken);
         this.startCDataToken = startCDataToken;
      }
      var textTokens = (GreenNode)reader.ReadValue();
      if (textTokens != null)
      {
         AdjustFlagsAndWidth(textTokens);
         this.textTokens = textTokens;
      }
      var endCDataToken = (SyntaxToken)reader.ReadValue();
      if (endCDataToken != null)
      {
         AdjustFlagsAndWidth(endCDataToken);
         this.endCDataToken = endCDataToken;
      }
    }

    internal override void WriteTo(ObjectWriter writer)
    {
      base.WriteTo(writer);
      writer.WriteValue(this.startCDataToken);
      writer.WriteValue(this.textTokens);
      writer.WriteValue(this.endCDataToken);
    }

    static XmlCDataSectionSyntax()
    {
       ObjectBinder.RegisterTypeReader(typeof(XmlCDataSectionSyntax), r => new XmlCDataSectionSyntax(r));
    }
  }

  internal sealed partial class XmlProcessingInstructionSyntax : XmlNodeSyntax
  {
    internal readonly SyntaxToken startProcessingInstructionToken;
    internal readonly XmlNameSyntax name;
    internal readonly GreenNode textTokens;
    internal readonly SyntaxToken endProcessingInstructionToken;

    internal XmlProcessingInstructionSyntax(SyntaxKind kind, SyntaxToken startProcessingInstructionToken, XmlNameSyntax name, GreenNode textTokens, SyntaxToken endProcessingInstructionToken, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
        : base(kind, diagnostics, annotations)
    {
        this.SlotCount = 4;
        this.AdjustFlagsAndWidth(startProcessingInstructionToken);
        this.startProcessingInstructionToken = startProcessingInstructionToken;
        this.AdjustFlagsAndWidth(name);
        this.name = name;
        if (textTokens != null)
        {
            this.AdjustFlagsAndWidth(textTokens);
            this.textTokens = textTokens;
        }
        this.AdjustFlagsAndWidth(endProcessingInstructionToken);
        this.endProcessingInstructionToken = endProcessingInstructionToken;
    }


    internal XmlProcessingInstructionSyntax(SyntaxKind kind, SyntaxToken startProcessingInstructionToken, XmlNameSyntax name, GreenNode textTokens, SyntaxToken endProcessingInstructionToken, SyntaxFactoryContext context)
        : base(kind)
    {
        this.SetFactoryContext(context);
        this.SlotCount = 4;
        this.AdjustFlagsAndWidth(startProcessingInstructionToken);
        this.startProcessingInstructionToken = startProcessingInstructionToken;
        this.AdjustFlagsAndWidth(name);
        this.name = name;
        if (textTokens != null)
        {
            this.AdjustFlagsAndWidth(textTokens);
            this.textTokens = textTokens;
        }
        this.AdjustFlagsAndWidth(endProcessingInstructionToken);
        this.endProcessingInstructionToken = endProcessingInstructionToken;
    }


    internal XmlProcessingInstructionSyntax(SyntaxKind kind, SyntaxToken startProcessingInstructionToken, XmlNameSyntax name, GreenNode textTokens, SyntaxToken endProcessingInstructionToken)
        : base(kind)
    {
        this.SlotCount = 4;
        this.AdjustFlagsAndWidth(startProcessingInstructionToken);
        this.startProcessingInstructionToken = startProcessingInstructionToken;
        this.AdjustFlagsAndWidth(name);
        this.name = name;
        if (textTokens != null)
        {
            this.AdjustFlagsAndWidth(textTokens);
            this.textTokens = textTokens;
        }
        this.AdjustFlagsAndWidth(endProcessingInstructionToken);
        this.endProcessingInstructionToken = endProcessingInstructionToken;
    }

    public SyntaxToken StartProcessingInstructionToken { get { return this.startProcessingInstructionToken; } }
    public XmlNameSyntax Name { get { return this.name; } }
    public Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<SyntaxToken> TextTokens { get { return new Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<SyntaxToken>(this.textTokens); } }
    public SyntaxToken EndProcessingInstructionToken { get { return this.endProcessingInstructionToken; } }

    internal override GreenNode GetSlot(int index)
    {
        switch (index)
        {
            case 0: return this.startProcessingInstructionToken;
            case 1: return this.name;
            case 2: return this.textTokens;
            case 3: return this.endProcessingInstructionToken;
            default: return null;
        }
    }

    internal override SyntaxNode CreateRed(SyntaxNode parent, int position)
    {
      return new Xml.Syntax.XmlProcessingInstructionSyntax(this, parent, position);
    }

    public override TResult Accept<TResult>(XmlSyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitXmlProcessingInstruction(this);
    }

    public override void Accept(XmlSyntaxVisitor visitor)
    {
        visitor.VisitXmlProcessingInstruction(this);
    }

    public XmlProcessingInstructionSyntax Update(SyntaxToken startProcessingInstructionToken, XmlNameSyntax name, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<SyntaxToken> textTokens, SyntaxToken endProcessingInstructionToken)
    {
        if (startProcessingInstructionToken != this.StartProcessingInstructionToken || name != this.Name || textTokens != this.TextTokens || endProcessingInstructionToken != this.EndProcessingInstructionToken)
        {
            var newNode = SyntaxFactory.XmlProcessingInstruction(startProcessingInstructionToken, name, textTokens, endProcessingInstructionToken);
            var diags = this.GetDiagnostics();
            if (diags != null && diags.Length > 0)
               newNode = newNode.WithDiagnosticsGreen(diags);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               newNode = newNode.WithAnnotationsGreen(annotations);
            return newNode;
        }

        return this;
    }

    internal override GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics)
    {
         return new XmlProcessingInstructionSyntax(this.Kind, this.startProcessingInstructionToken, this.name, this.textTokens, this.endProcessingInstructionToken, diagnostics, GetAnnotations());
    }

    internal override GreenNode SetAnnotations(SyntaxAnnotation[] annotations)
    {
         return new XmlProcessingInstructionSyntax(this.Kind, this.startProcessingInstructionToken, this.name, this.textTokens, this.endProcessingInstructionToken, GetDiagnostics(), annotations);
    }

    internal XmlProcessingInstructionSyntax(ObjectReader reader)
        : base(reader)
    {
      this.SlotCount = 4;
      var startProcessingInstructionToken = (SyntaxToken)reader.ReadValue();
      if (startProcessingInstructionToken != null)
      {
         AdjustFlagsAndWidth(startProcessingInstructionToken);
         this.startProcessingInstructionToken = startProcessingInstructionToken;
      }
      var name = (XmlNameSyntax)reader.ReadValue();
      if (name != null)
      {
         AdjustFlagsAndWidth(name);
         this.name = name;
      }
      var textTokens = (GreenNode)reader.ReadValue();
      if (textTokens != null)
      {
         AdjustFlagsAndWidth(textTokens);
         this.textTokens = textTokens;
      }
      var endProcessingInstructionToken = (SyntaxToken)reader.ReadValue();
      if (endProcessingInstructionToken != null)
      {
         AdjustFlagsAndWidth(endProcessingInstructionToken);
         this.endProcessingInstructionToken = endProcessingInstructionToken;
      }
    }

    internal override void WriteTo(ObjectWriter writer)
    {
      base.WriteTo(writer);
      writer.WriteValue(this.startProcessingInstructionToken);
      writer.WriteValue(this.name);
      writer.WriteValue(this.textTokens);
      writer.WriteValue(this.endProcessingInstructionToken);
    }

    static XmlProcessingInstructionSyntax()
    {
       ObjectBinder.RegisterTypeReader(typeof(XmlProcessingInstructionSyntax), r => new XmlProcessingInstructionSyntax(r));
    }
  }

  internal sealed partial class XmlCommentSyntax : XmlNodeSyntax
  {
    internal readonly SyntaxToken lessThanExclamationMinusMinusToken;
    internal readonly GreenNode textTokens;
    internal readonly SyntaxToken minusMinusGreaterThanToken;

    internal XmlCommentSyntax(SyntaxKind kind, SyntaxToken lessThanExclamationMinusMinusToken, GreenNode textTokens, SyntaxToken minusMinusGreaterThanToken, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
        : base(kind, diagnostics, annotations)
    {
        this.SlotCount = 3;
        this.AdjustFlagsAndWidth(lessThanExclamationMinusMinusToken);
        this.lessThanExclamationMinusMinusToken = lessThanExclamationMinusMinusToken;
        if (textTokens != null)
        {
            this.AdjustFlagsAndWidth(textTokens);
            this.textTokens = textTokens;
        }
        this.AdjustFlagsAndWidth(minusMinusGreaterThanToken);
        this.minusMinusGreaterThanToken = minusMinusGreaterThanToken;
    }


    internal XmlCommentSyntax(SyntaxKind kind, SyntaxToken lessThanExclamationMinusMinusToken, GreenNode textTokens, SyntaxToken minusMinusGreaterThanToken, SyntaxFactoryContext context)
        : base(kind)
    {
        this.SetFactoryContext(context);
        this.SlotCount = 3;
        this.AdjustFlagsAndWidth(lessThanExclamationMinusMinusToken);
        this.lessThanExclamationMinusMinusToken = lessThanExclamationMinusMinusToken;
        if (textTokens != null)
        {
            this.AdjustFlagsAndWidth(textTokens);
            this.textTokens = textTokens;
        }
        this.AdjustFlagsAndWidth(minusMinusGreaterThanToken);
        this.minusMinusGreaterThanToken = minusMinusGreaterThanToken;
    }


    internal XmlCommentSyntax(SyntaxKind kind, SyntaxToken lessThanExclamationMinusMinusToken, GreenNode textTokens, SyntaxToken minusMinusGreaterThanToken)
        : base(kind)
    {
        this.SlotCount = 3;
        this.AdjustFlagsAndWidth(lessThanExclamationMinusMinusToken);
        this.lessThanExclamationMinusMinusToken = lessThanExclamationMinusMinusToken;
        if (textTokens != null)
        {
            this.AdjustFlagsAndWidth(textTokens);
            this.textTokens = textTokens;
        }
        this.AdjustFlagsAndWidth(minusMinusGreaterThanToken);
        this.minusMinusGreaterThanToken = minusMinusGreaterThanToken;
    }

    public SyntaxToken LessThanExclamationMinusMinusToken { get { return this.lessThanExclamationMinusMinusToken; } }
    public Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<SyntaxToken> TextTokens { get { return new Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<SyntaxToken>(this.textTokens); } }
    public SyntaxToken MinusMinusGreaterThanToken { get { return this.minusMinusGreaterThanToken; } }

    internal override GreenNode GetSlot(int index)
    {
        switch (index)
        {
            case 0: return this.lessThanExclamationMinusMinusToken;
            case 1: return this.textTokens;
            case 2: return this.minusMinusGreaterThanToken;
            default: return null;
        }
    }

    internal override SyntaxNode CreateRed(SyntaxNode parent, int position)
    {
      return new Xml.Syntax.XmlCommentSyntax(this, parent, position);
    }

    public override TResult Accept<TResult>(XmlSyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitXmlComment(this);
    }

    public override void Accept(XmlSyntaxVisitor visitor)
    {
        visitor.VisitXmlComment(this);
    }

    public XmlCommentSyntax Update(SyntaxToken lessThanExclamationMinusMinusToken, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<SyntaxToken> textTokens, SyntaxToken minusMinusGreaterThanToken)
    {
        if (lessThanExclamationMinusMinusToken != this.LessThanExclamationMinusMinusToken || textTokens != this.TextTokens || minusMinusGreaterThanToken != this.MinusMinusGreaterThanToken)
        {
            var newNode = SyntaxFactory.XmlComment(lessThanExclamationMinusMinusToken, textTokens, minusMinusGreaterThanToken);
            var diags = this.GetDiagnostics();
            if (diags != null && diags.Length > 0)
               newNode = newNode.WithDiagnosticsGreen(diags);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               newNode = newNode.WithAnnotationsGreen(annotations);
            return newNode;
        }

        return this;
    }

    internal override GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics)
    {
         return new XmlCommentSyntax(this.Kind, this.lessThanExclamationMinusMinusToken, this.textTokens, this.minusMinusGreaterThanToken, diagnostics, GetAnnotations());
    }

    internal override GreenNode SetAnnotations(SyntaxAnnotation[] annotations)
    {
         return new XmlCommentSyntax(this.Kind, this.lessThanExclamationMinusMinusToken, this.textTokens, this.minusMinusGreaterThanToken, GetDiagnostics(), annotations);
    }

    internal XmlCommentSyntax(ObjectReader reader)
        : base(reader)
    {
      this.SlotCount = 3;
      var lessThanExclamationMinusMinusToken = (SyntaxToken)reader.ReadValue();
      if (lessThanExclamationMinusMinusToken != null)
      {
         AdjustFlagsAndWidth(lessThanExclamationMinusMinusToken);
         this.lessThanExclamationMinusMinusToken = lessThanExclamationMinusMinusToken;
      }
      var textTokens = (GreenNode)reader.ReadValue();
      if (textTokens != null)
      {
         AdjustFlagsAndWidth(textTokens);
         this.textTokens = textTokens;
      }
      var minusMinusGreaterThanToken = (SyntaxToken)reader.ReadValue();
      if (minusMinusGreaterThanToken != null)
      {
         AdjustFlagsAndWidth(minusMinusGreaterThanToken);
         this.minusMinusGreaterThanToken = minusMinusGreaterThanToken;
      }
    }

    internal override void WriteTo(ObjectWriter writer)
    {
      base.WriteTo(writer);
      writer.WriteValue(this.lessThanExclamationMinusMinusToken);
      writer.WriteValue(this.textTokens);
      writer.WriteValue(this.minusMinusGreaterThanToken);
    }

    static XmlCommentSyntax()
    {
       ObjectBinder.RegisterTypeReader(typeof(XmlCommentSyntax), r => new XmlCommentSyntax(r));
    }
  }

  internal sealed partial class SkippedTokensTriviaSyntax : StructuredTriviaSyntax
  {
    internal readonly GreenNode tokens;

    internal SkippedTokensTriviaSyntax(SyntaxKind kind, GreenNode tokens, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
        : base(kind, diagnostics, annotations)
    {
        this.SlotCount = 1;
        if (tokens != null)
        {
            this.AdjustFlagsAndWidth(tokens);
            this.tokens = tokens;
        }
    }


    internal SkippedTokensTriviaSyntax(SyntaxKind kind, GreenNode tokens, SyntaxFactoryContext context)
        : base(kind)
    {
        this.SetFactoryContext(context);
        this.SlotCount = 1;
        if (tokens != null)
        {
            this.AdjustFlagsAndWidth(tokens);
            this.tokens = tokens;
        }
    }


    internal SkippedTokensTriviaSyntax(SyntaxKind kind, GreenNode tokens)
        : base(kind)
    {
        this.SlotCount = 1;
        if (tokens != null)
        {
            this.AdjustFlagsAndWidth(tokens);
            this.tokens = tokens;
        }
    }

    public Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<SyntaxToken> Tokens { get { return new Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<SyntaxToken>(this.tokens); } }

    internal override GreenNode GetSlot(int index)
    {
        switch (index)
        {
            case 0: return this.tokens;
            default: return null;
        }
    }

    internal override SyntaxNode CreateRed(SyntaxNode parent, int position)
    {
      return new Xml.Syntax.SkippedTokensTriviaSyntax(this, parent, position);
    }

    public override TResult Accept<TResult>(XmlSyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitSkippedTokensTrivia(this);
    }

    public override void Accept(XmlSyntaxVisitor visitor)
    {
        visitor.VisitSkippedTokensTrivia(this);
    }

    public SkippedTokensTriviaSyntax Update(Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<SyntaxToken> tokens)
    {
        if (tokens != this.Tokens)
        {
            var newNode = SyntaxFactory.SkippedTokensTrivia(tokens);
            var diags = this.GetDiagnostics();
            if (diags != null && diags.Length > 0)
               newNode = newNode.WithDiagnosticsGreen(diags);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               newNode = newNode.WithAnnotationsGreen(annotations);
            return newNode;
        }

        return this;
    }

    internal override GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics)
    {
         return new SkippedTokensTriviaSyntax(this.Kind, this.tokens, diagnostics, GetAnnotations());
    }

    internal override GreenNode SetAnnotations(SyntaxAnnotation[] annotations)
    {
         return new SkippedTokensTriviaSyntax(this.Kind, this.tokens, GetDiagnostics(), annotations);
    }

    internal SkippedTokensTriviaSyntax(ObjectReader reader)
        : base(reader)
    {
      this.SlotCount = 1;
      var tokens = (GreenNode)reader.ReadValue();
      if (tokens != null)
      {
         AdjustFlagsAndWidth(tokens);
         this.tokens = tokens;
      }
    }

    internal override void WriteTo(ObjectWriter writer)
    {
      base.WriteTo(writer);
      writer.WriteValue(this.tokens);
    }

    static SkippedTokensTriviaSyntax()
    {
       ObjectBinder.RegisterTypeReader(typeof(SkippedTokensTriviaSyntax), r => new SkippedTokensTriviaSyntax(r));
    }
  }

  internal partial class XmlSyntaxVisitor<TResult>
  {
    public virtual TResult VisitXmlBody(XmlBodySyntax node)
    {
      return this.DefaultVisit(node);
    }

    public virtual TResult VisitIdentifierName(IdentifierNameSyntax node)
    {
      return this.DefaultVisit(node);
    }

    public virtual TResult VisitQualifiedName(QualifiedNameSyntax node)
    {
      return this.DefaultVisit(node);
    }

    public virtual TResult VisitXmlElement(XmlElementSyntax node)
    {
      return this.DefaultVisit(node);
    }

    public virtual TResult VisitXmlElementStartTag(XmlElementStartTagSyntax node)
    {
      return this.DefaultVisit(node);
    }

    public virtual TResult VisitXmlElementEndTag(XmlElementEndTagSyntax node)
    {
      return this.DefaultVisit(node);
    }

    public virtual TResult VisitXmlEmptyElement(XmlEmptyElementSyntax node)
    {
      return this.DefaultVisit(node);
    }

    public virtual TResult VisitXmlName(XmlNameSyntax node)
    {
      return this.DefaultVisit(node);
    }

    public virtual TResult VisitXmlPrefix(XmlPrefixSyntax node)
    {
      return this.DefaultVisit(node);
    }

    public virtual TResult VisitXmlTextAttribute(XmlTextAttributeSyntax node)
    {
      return this.DefaultVisit(node);
    }

    public virtual TResult VisitXmlNameAttribute(XmlNameAttributeSyntax node)
    {
      return this.DefaultVisit(node);
    }

    public virtual TResult VisitXmlText(XmlTextSyntax node)
    {
      return this.DefaultVisit(node);
    }

    public virtual TResult VisitXmlCDataSection(XmlCDataSectionSyntax node)
    {
      return this.DefaultVisit(node);
    }

    public virtual TResult VisitXmlProcessingInstruction(XmlProcessingInstructionSyntax node)
    {
      return this.DefaultVisit(node);
    }

    public virtual TResult VisitXmlComment(XmlCommentSyntax node)
    {
      return this.DefaultVisit(node);
    }

    public virtual TResult VisitSkippedTokensTrivia(SkippedTokensTriviaSyntax node)
    {
      return this.DefaultVisit(node);
    }
  }


  internal partial class XmlSyntaxVisitor
  {
    public virtual void VisitXmlBody(XmlBodySyntax node)
    {
      this.DefaultVisit(node);
    }

    public virtual void VisitIdentifierName(IdentifierNameSyntax node)
    {
      this.DefaultVisit(node);
    }

    public virtual void VisitQualifiedName(QualifiedNameSyntax node)
    {
      this.DefaultVisit(node);
    }

    public virtual void VisitXmlElement(XmlElementSyntax node)
    {
      this.DefaultVisit(node);
    }

    public virtual void VisitXmlElementStartTag(XmlElementStartTagSyntax node)
    {
      this.DefaultVisit(node);
    }

    public virtual void VisitXmlElementEndTag(XmlElementEndTagSyntax node)
    {
      this.DefaultVisit(node);
    }

    public virtual void VisitXmlEmptyElement(XmlEmptyElementSyntax node)
    {
      this.DefaultVisit(node);
    }

    public virtual void VisitXmlName(XmlNameSyntax node)
    {
      this.DefaultVisit(node);
    }

    public virtual void VisitXmlPrefix(XmlPrefixSyntax node)
    {
      this.DefaultVisit(node);
    }

    public virtual void VisitXmlTextAttribute(XmlTextAttributeSyntax node)
    {
      this.DefaultVisit(node);
    }

    public virtual void VisitXmlNameAttribute(XmlNameAttributeSyntax node)
    {
      this.DefaultVisit(node);
    }

    public virtual void VisitXmlText(XmlTextSyntax node)
    {
      this.DefaultVisit(node);
    }

    public virtual void VisitXmlCDataSection(XmlCDataSectionSyntax node)
    {
      this.DefaultVisit(node);
    }

    public virtual void VisitXmlProcessingInstruction(XmlProcessingInstructionSyntax node)
    {
      this.DefaultVisit(node);
    }

    public virtual void VisitXmlComment(XmlCommentSyntax node)
    {
      this.DefaultVisit(node);
    }

    public virtual void VisitSkippedTokensTrivia(SkippedTokensTriviaSyntax node)
    {
      this.DefaultVisit(node);
    }
  }

  internal partial class XmlSyntaxRewriter : XmlSyntaxVisitor<XmlSyntaxNode>
  {
    public override XmlSyntaxNode VisitXmlBody(XmlBodySyntax node)
    {
      var elements = this.VisitList(node.Elements);
      var endOfFileToken = (SyntaxToken)this.Visit(node.EndOfFileToken);
      return node.Update(elements, endOfFileToken);
    }

    public override XmlSyntaxNode VisitIdentifierName(IdentifierNameSyntax node)
    {
      var identifier = (SyntaxToken)this.Visit(node.Identifier);
      return node.Update(identifier);
    }

    public override XmlSyntaxNode VisitQualifiedName(QualifiedNameSyntax node)
    {
      var left = (NameSyntax)this.Visit(node.Left);
      var dotToken = (SyntaxToken)this.Visit(node.DotToken);
      var right = (SimpleNameSyntax)this.Visit(node.Right);
      return node.Update(left, dotToken, right);
    }

    public override XmlSyntaxNode VisitXmlElement(XmlElementSyntax node)
    {
      var startTag = (XmlElementStartTagSyntax)this.Visit(node.StartTag);
      var content = this.VisitList(node.Content);
      var endTag = (XmlElementEndTagSyntax)this.Visit(node.EndTag);
      return node.Update(startTag, content, endTag);
    }

    public override XmlSyntaxNode VisitXmlElementStartTag(XmlElementStartTagSyntax node)
    {
      var lessThanToken = (SyntaxToken)this.Visit(node.LessThanToken);
      var name = (XmlNameSyntax)this.Visit(node.Name);
      var attributes = this.VisitList(node.Attributes);
      var greaterThanToken = (SyntaxToken)this.Visit(node.GreaterThanToken);
      return node.Update(lessThanToken, name, attributes, greaterThanToken);
    }

    public override XmlSyntaxNode VisitXmlElementEndTag(XmlElementEndTagSyntax node)
    {
      var lessThanSlashToken = (SyntaxToken)this.Visit(node.LessThanSlashToken);
      var name = (XmlNameSyntax)this.Visit(node.Name);
      var greaterThanToken = (SyntaxToken)this.Visit(node.GreaterThanToken);
      return node.Update(lessThanSlashToken, name, greaterThanToken);
    }

    public override XmlSyntaxNode VisitXmlEmptyElement(XmlEmptyElementSyntax node)
    {
      var lessThanToken = (SyntaxToken)this.Visit(node.LessThanToken);
      var name = (XmlNameSyntax)this.Visit(node.Name);
      var attributes = this.VisitList(node.Attributes);
      var slashGreaterThanToken = (SyntaxToken)this.Visit(node.SlashGreaterThanToken);
      return node.Update(lessThanToken, name, attributes, slashGreaterThanToken);
    }

    public override XmlSyntaxNode VisitXmlName(XmlNameSyntax node)
    {
      var prefix = (XmlPrefixSyntax)this.Visit(node.Prefix);
      var localName = (SyntaxToken)this.Visit(node.LocalName);
      return node.Update(prefix, localName);
    }

    public override XmlSyntaxNode VisitXmlPrefix(XmlPrefixSyntax node)
    {
      var prefix = (SyntaxToken)this.Visit(node.Prefix);
      var colonToken = (SyntaxToken)this.Visit(node.ColonToken);
      return node.Update(prefix, colonToken);
    }

    public override XmlSyntaxNode VisitXmlTextAttribute(XmlTextAttributeSyntax node)
    {
      var name = (XmlNameSyntax)this.Visit(node.Name);
      var equalsToken = (SyntaxToken)this.Visit(node.EqualsToken);
      var startQuoteToken = (SyntaxToken)this.Visit(node.StartQuoteToken);
      var textTokens = this.VisitList(node.TextTokens);
      var endQuoteToken = (SyntaxToken)this.Visit(node.EndQuoteToken);
      return node.Update(name, equalsToken, startQuoteToken, textTokens, endQuoteToken);
    }

    public override XmlSyntaxNode VisitXmlNameAttribute(XmlNameAttributeSyntax node)
    {
      var name = (XmlNameSyntax)this.Visit(node.Name);
      var equalsToken = (SyntaxToken)this.Visit(node.EqualsToken);
      var startQuoteToken = (SyntaxToken)this.Visit(node.StartQuoteToken);
      var identifier = (IdentifierNameSyntax)this.Visit(node.Identifier);
      var endQuoteToken = (SyntaxToken)this.Visit(node.EndQuoteToken);
      return node.Update(name, equalsToken, startQuoteToken, identifier, endQuoteToken);
    }

    public override XmlSyntaxNode VisitXmlText(XmlTextSyntax node)
    {
      var textTokens = this.VisitList(node.TextTokens);
      return node.Update(textTokens);
    }

    public override XmlSyntaxNode VisitXmlCDataSection(XmlCDataSectionSyntax node)
    {
      var startCDataToken = (SyntaxToken)this.Visit(node.StartCDataToken);
      var textTokens = this.VisitList(node.TextTokens);
      var endCDataToken = (SyntaxToken)this.Visit(node.EndCDataToken);
      return node.Update(startCDataToken, textTokens, endCDataToken);
    }

    public override XmlSyntaxNode VisitXmlProcessingInstruction(XmlProcessingInstructionSyntax node)
    {
      var startProcessingInstructionToken = (SyntaxToken)this.Visit(node.StartProcessingInstructionToken);
      var name = (XmlNameSyntax)this.Visit(node.Name);
      var textTokens = this.VisitList(node.TextTokens);
      var endProcessingInstructionToken = (SyntaxToken)this.Visit(node.EndProcessingInstructionToken);
      return node.Update(startProcessingInstructionToken, name, textTokens, endProcessingInstructionToken);
    }

    public override XmlSyntaxNode VisitXmlComment(XmlCommentSyntax node)
    {
      var lessThanExclamationMinusMinusToken = (SyntaxToken)this.Visit(node.LessThanExclamationMinusMinusToken);
      var textTokens = this.VisitList(node.TextTokens);
      var minusMinusGreaterThanToken = (SyntaxToken)this.Visit(node.MinusMinusGreaterThanToken);
      return node.Update(lessThanExclamationMinusMinusToken, textTokens, minusMinusGreaterThanToken);
    }

    public override XmlSyntaxNode VisitSkippedTokensTrivia(SkippedTokensTriviaSyntax node)
    {
      var tokens = this.VisitList(node.Tokens);
      return node.Update(tokens);
    }
  }

  internal partial class ContextAwareSyntax
  {
    private SyntaxFactoryContext context;


    public ContextAwareSyntax(SyntaxFactoryContext context)
    {
        this.context = context;
    }
    public XmlBodySyntax XmlBody(Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<XmlSyntaxNode> elements, SyntaxToken endOfFileToken)
    {
#if DEBUG
      if (endOfFileToken == null)
        throw new ArgumentNullException(nameof(endOfFileToken));
      switch (endOfFileToken.Kind)
      {
        case SyntaxKind.EndOfFileToken:
          break;
        default:
          throw new ArgumentException("endOfFileToken");
      }
#endif

      int hash;
      var cached = XmlSyntaxNodeCache.TryGetNode((int)SyntaxKind.XmlBody, elements.Node, endOfFileToken, this.context, out hash);
      if (cached != null) return (XmlBodySyntax)cached;

      var result = new XmlBodySyntax(SyntaxKind.XmlBody, elements.Node, endOfFileToken, this.context);
      if (hash >= 0)
      {
          SyntaxNodeCache.AddNode(result, hash);
      }

      return result;
    }

    public IdentifierNameSyntax IdentifierName(SyntaxToken identifier)
    {
#if DEBUG
      if (identifier == null)
        throw new ArgumentNullException(nameof(identifier));
      switch (identifier.Kind)
      {
        case SyntaxKind.IdentifierToken:
          break;
        default:
          throw new ArgumentException("identifier");
      }
#endif

      int hash;
      var cached = XmlSyntaxNodeCache.TryGetNode((int)SyntaxKind.IdentifierName, identifier, this.context, out hash);
      if (cached != null) return (IdentifierNameSyntax)cached;

      var result = new IdentifierNameSyntax(SyntaxKind.IdentifierName, identifier, this.context);
      if (hash >= 0)
      {
          SyntaxNodeCache.AddNode(result, hash);
      }

      return result;
    }

    public QualifiedNameSyntax QualifiedName(NameSyntax left, SyntaxToken dotToken, SimpleNameSyntax right)
    {
#if DEBUG
      if (left == null)
        throw new ArgumentNullException(nameof(left));
      if (dotToken == null)
        throw new ArgumentNullException(nameof(dotToken));
      switch (dotToken.Kind)
      {
        case SyntaxKind.DotToken:
          break;
        default:
          throw new ArgumentException("dotToken");
      }
      if (right == null)
        throw new ArgumentNullException(nameof(right));
#endif

      int hash;
      var cached = XmlSyntaxNodeCache.TryGetNode((int)SyntaxKind.QualifiedName, left, dotToken, right, this.context, out hash);
      if (cached != null) return (QualifiedNameSyntax)cached;

      var result = new QualifiedNameSyntax(SyntaxKind.QualifiedName, left, dotToken, right, this.context);
      if (hash >= 0)
      {
          SyntaxNodeCache.AddNode(result, hash);
      }

      return result;
    }

    public XmlElementSyntax XmlElement(XmlElementStartTagSyntax startTag, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<XmlSyntaxNode> content, XmlElementEndTagSyntax endTag)
    {
#if DEBUG
      if (startTag == null)
        throw new ArgumentNullException(nameof(startTag));
      if (endTag == null)
        throw new ArgumentNullException(nameof(endTag));
#endif

      int hash;
      var cached = XmlSyntaxNodeCache.TryGetNode((int)SyntaxKind.XmlElement, startTag, content.Node, endTag, this.context, out hash);
      if (cached != null) return (XmlElementSyntax)cached;

      var result = new XmlElementSyntax(SyntaxKind.XmlElement, startTag, content.Node, endTag, this.context);
      if (hash >= 0)
      {
          SyntaxNodeCache.AddNode(result, hash);
      }

      return result;
    }

    public XmlElementStartTagSyntax XmlElementStartTag(SyntaxToken lessThanToken, XmlNameSyntax name, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<XmlAttributeSyntax> attributes, SyntaxToken greaterThanToken)
    {
#if DEBUG
      if (lessThanToken == null)
        throw new ArgumentNullException(nameof(lessThanToken));
      switch (lessThanToken.Kind)
      {
        case SyntaxKind.LessThanToken:
          break;
        default:
          throw new ArgumentException("lessThanToken");
      }
      if (name == null)
        throw new ArgumentNullException(nameof(name));
      if (greaterThanToken == null)
        throw new ArgumentNullException(nameof(greaterThanToken));
      switch (greaterThanToken.Kind)
      {
        case SyntaxKind.GreaterThanToken:
          break;
        default:
          throw new ArgumentException("greaterThanToken");
      }
#endif

      return new XmlElementStartTagSyntax(SyntaxKind.XmlElementStartTag, lessThanToken, name, attributes.Node, greaterThanToken, this.context);
    }

    public XmlElementEndTagSyntax XmlElementEndTag(SyntaxToken lessThanSlashToken, XmlNameSyntax name, SyntaxToken greaterThanToken)
    {
#if DEBUG
      if (lessThanSlashToken == null)
        throw new ArgumentNullException(nameof(lessThanSlashToken));
      switch (lessThanSlashToken.Kind)
      {
        case SyntaxKind.LessThanSlashToken:
          break;
        default:
          throw new ArgumentException("lessThanSlashToken");
      }
      if (name == null)
        throw new ArgumentNullException(nameof(name));
      if (greaterThanToken == null)
        throw new ArgumentNullException(nameof(greaterThanToken));
      switch (greaterThanToken.Kind)
      {
        case SyntaxKind.GreaterThanToken:
          break;
        default:
          throw new ArgumentException("greaterThanToken");
      }
#endif

      int hash;
      var cached = XmlSyntaxNodeCache.TryGetNode((int)SyntaxKind.XmlElementEndTag, lessThanSlashToken, name, greaterThanToken, this.context, out hash);
      if (cached != null) return (XmlElementEndTagSyntax)cached;

      var result = new XmlElementEndTagSyntax(SyntaxKind.XmlElementEndTag, lessThanSlashToken, name, greaterThanToken, this.context);
      if (hash >= 0)
      {
          SyntaxNodeCache.AddNode(result, hash);
      }

      return result;
    }

    public XmlEmptyElementSyntax XmlEmptyElement(SyntaxToken lessThanToken, XmlNameSyntax name, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<XmlAttributeSyntax> attributes, SyntaxToken slashGreaterThanToken)
    {
#if DEBUG
      if (lessThanToken == null)
        throw new ArgumentNullException(nameof(lessThanToken));
      switch (lessThanToken.Kind)
      {
        case SyntaxKind.LessThanToken:
          break;
        default:
          throw new ArgumentException("lessThanToken");
      }
      if (name == null)
        throw new ArgumentNullException(nameof(name));
      if (slashGreaterThanToken == null)
        throw new ArgumentNullException(nameof(slashGreaterThanToken));
      switch (slashGreaterThanToken.Kind)
      {
        case SyntaxKind.SlashGreaterThanToken:
          break;
        default:
          throw new ArgumentException("slashGreaterThanToken");
      }
#endif

      return new XmlEmptyElementSyntax(SyntaxKind.XmlEmptyElement, lessThanToken, name, attributes.Node, slashGreaterThanToken, this.context);
    }

    public XmlNameSyntax XmlName(XmlPrefixSyntax prefix, SyntaxToken localName)
    {
#if DEBUG
      if (localName == null)
        throw new ArgumentNullException(nameof(localName));
      switch (localName.Kind)
      {
        case SyntaxKind.IdentifierToken:
          break;
        default:
          throw new ArgumentException("localName");
      }
#endif

      int hash;
      var cached = XmlSyntaxNodeCache.TryGetNode((int)SyntaxKind.XmlName, prefix, localName, this.context, out hash);
      if (cached != null) return (XmlNameSyntax)cached;

      var result = new XmlNameSyntax(SyntaxKind.XmlName, prefix, localName, this.context);
      if (hash >= 0)
      {
          SyntaxNodeCache.AddNode(result, hash);
      }

      return result;
    }

    public XmlPrefixSyntax XmlPrefix(SyntaxToken prefix, SyntaxToken colonToken)
    {
#if DEBUG
      if (prefix == null)
        throw new ArgumentNullException(nameof(prefix));
      switch (prefix.Kind)
      {
        case SyntaxKind.IdentifierToken:
          break;
        default:
          throw new ArgumentException("prefix");
      }
      if (colonToken == null)
        throw new ArgumentNullException(nameof(colonToken));
      switch (colonToken.Kind)
      {
        case SyntaxKind.ColonToken:
          break;
        default:
          throw new ArgumentException("colonToken");
      }
#endif

      int hash;
      var cached = XmlSyntaxNodeCache.TryGetNode((int)SyntaxKind.XmlPrefix, prefix, colonToken, this.context, out hash);
      if (cached != null) return (XmlPrefixSyntax)cached;

      var result = new XmlPrefixSyntax(SyntaxKind.XmlPrefix, prefix, colonToken, this.context);
      if (hash >= 0)
      {
          SyntaxNodeCache.AddNode(result, hash);
      }

      return result;
    }

    public XmlTextAttributeSyntax XmlTextAttribute(XmlNameSyntax name, SyntaxToken equalsToken, SyntaxToken startQuoteToken, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<SyntaxToken> textTokens, SyntaxToken endQuoteToken)
    {
#if DEBUG
      if (name == null)
        throw new ArgumentNullException(nameof(name));
      if (equalsToken == null)
        throw new ArgumentNullException(nameof(equalsToken));
      switch (equalsToken.Kind)
      {
        case SyntaxKind.EqualsToken:
          break;
        default:
          throw new ArgumentException("equalsToken");
      }
      if (startQuoteToken == null)
        throw new ArgumentNullException(nameof(startQuoteToken));
      switch (startQuoteToken.Kind)
      {
        case SyntaxKind.SingleQuoteToken:
        case SyntaxKind.DoubleQuoteToken:
          break;
        default:
          throw new ArgumentException("startQuoteToken");
      }
      if (endQuoteToken == null)
        throw new ArgumentNullException(nameof(endQuoteToken));
      switch (endQuoteToken.Kind)
      {
        case SyntaxKind.SingleQuoteToken:
        case SyntaxKind.DoubleQuoteToken:
          break;
        default:
          throw new ArgumentException("endQuoteToken");
      }
#endif

      return new XmlTextAttributeSyntax(SyntaxKind.XmlTextAttribute, name, equalsToken, startQuoteToken, textTokens.Node, endQuoteToken, this.context);
    }

    public XmlNameAttributeSyntax XmlNameAttribute(XmlNameSyntax name, SyntaxToken equalsToken, SyntaxToken startQuoteToken, IdentifierNameSyntax identifier, SyntaxToken endQuoteToken)
    {
#if DEBUG
      if (name == null)
        throw new ArgumentNullException(nameof(name));
      if (equalsToken == null)
        throw new ArgumentNullException(nameof(equalsToken));
      switch (equalsToken.Kind)
      {
        case SyntaxKind.EqualsToken:
          break;
        default:
          throw new ArgumentException("equalsToken");
      }
      if (startQuoteToken == null)
        throw new ArgumentNullException(nameof(startQuoteToken));
      switch (startQuoteToken.Kind)
      {
        case SyntaxKind.SingleQuoteToken:
        case SyntaxKind.DoubleQuoteToken:
          break;
        default:
          throw new ArgumentException("startQuoteToken");
      }
      if (identifier == null)
        throw new ArgumentNullException(nameof(identifier));
      if (endQuoteToken == null)
        throw new ArgumentNullException(nameof(endQuoteToken));
      switch (endQuoteToken.Kind)
      {
        case SyntaxKind.SingleQuoteToken:
        case SyntaxKind.DoubleQuoteToken:
          break;
        default:
          throw new ArgumentException("endQuoteToken");
      }
#endif

      return new XmlNameAttributeSyntax(SyntaxKind.XmlNameAttribute, name, equalsToken, startQuoteToken, identifier, endQuoteToken, this.context);
    }

    public XmlTextSyntax XmlText(Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<SyntaxToken> textTokens)
    {
#if DEBUG
#endif

      int hash;
      var cached = XmlSyntaxNodeCache.TryGetNode((int)SyntaxKind.XmlText, textTokens.Node, this.context, out hash);
      if (cached != null) return (XmlTextSyntax)cached;

      var result = new XmlTextSyntax(SyntaxKind.XmlText, textTokens.Node, this.context);
      if (hash >= 0)
      {
          SyntaxNodeCache.AddNode(result, hash);
      }

      return result;
    }

    public XmlCDataSectionSyntax XmlCDataSection(SyntaxToken startCDataToken, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<SyntaxToken> textTokens, SyntaxToken endCDataToken)
    {
#if DEBUG
      if (startCDataToken == null)
        throw new ArgumentNullException(nameof(startCDataToken));
      switch (startCDataToken.Kind)
      {
        case SyntaxKind.XmlCDataStartToken:
          break;
        default:
          throw new ArgumentException("startCDataToken");
      }
      if (endCDataToken == null)
        throw new ArgumentNullException(nameof(endCDataToken));
      switch (endCDataToken.Kind)
      {
        case SyntaxKind.XmlCDataEndToken:
          break;
        default:
          throw new ArgumentException("endCDataToken");
      }
#endif

      int hash;
      var cached = XmlSyntaxNodeCache.TryGetNode((int)SyntaxKind.XmlCDataSection, startCDataToken, textTokens.Node, endCDataToken, this.context, out hash);
      if (cached != null) return (XmlCDataSectionSyntax)cached;

      var result = new XmlCDataSectionSyntax(SyntaxKind.XmlCDataSection, startCDataToken, textTokens.Node, endCDataToken, this.context);
      if (hash >= 0)
      {
          SyntaxNodeCache.AddNode(result, hash);
      }

      return result;
    }

    public XmlProcessingInstructionSyntax XmlProcessingInstruction(SyntaxToken startProcessingInstructionToken, XmlNameSyntax name, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<SyntaxToken> textTokens, SyntaxToken endProcessingInstructionToken)
    {
#if DEBUG
      if (startProcessingInstructionToken == null)
        throw new ArgumentNullException(nameof(startProcessingInstructionToken));
      switch (startProcessingInstructionToken.Kind)
      {
        case SyntaxKind.XmlProcessingInstructionStartToken:
          break;
        default:
          throw new ArgumentException("startProcessingInstructionToken");
      }
      if (name == null)
        throw new ArgumentNullException(nameof(name));
      if (endProcessingInstructionToken == null)
        throw new ArgumentNullException(nameof(endProcessingInstructionToken));
      switch (endProcessingInstructionToken.Kind)
      {
        case SyntaxKind.XmlProcessingInstructionEndToken:
          break;
        default:
          throw new ArgumentException("endProcessingInstructionToken");
      }
#endif

      return new XmlProcessingInstructionSyntax(SyntaxKind.XmlProcessingInstruction, startProcessingInstructionToken, name, textTokens.Node, endProcessingInstructionToken, this.context);
    }

    public XmlCommentSyntax XmlComment(SyntaxToken lessThanExclamationMinusMinusToken, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<SyntaxToken> textTokens, SyntaxToken minusMinusGreaterThanToken)
    {
#if DEBUG
      if (lessThanExclamationMinusMinusToken == null)
        throw new ArgumentNullException(nameof(lessThanExclamationMinusMinusToken));
      switch (lessThanExclamationMinusMinusToken.Kind)
      {
        case SyntaxKind.XmlCommentStartToken:
          break;
        default:
          throw new ArgumentException("lessThanExclamationMinusMinusToken");
      }
      if (minusMinusGreaterThanToken == null)
        throw new ArgumentNullException(nameof(minusMinusGreaterThanToken));
      switch (minusMinusGreaterThanToken.Kind)
      {
        case SyntaxKind.XmlCommentEndToken:
          break;
        default:
          throw new ArgumentException("minusMinusGreaterThanToken");
      }
#endif

      int hash;
      var cached = XmlSyntaxNodeCache.TryGetNode((int)SyntaxKind.XmlComment, lessThanExclamationMinusMinusToken, textTokens.Node, minusMinusGreaterThanToken, this.context, out hash);
      if (cached != null) return (XmlCommentSyntax)cached;

      var result = new XmlCommentSyntax(SyntaxKind.XmlComment, lessThanExclamationMinusMinusToken, textTokens.Node, minusMinusGreaterThanToken, this.context);
      if (hash >= 0)
      {
          SyntaxNodeCache.AddNode(result, hash);
      }

      return result;
    }

    public SkippedTokensTriviaSyntax SkippedTokensTrivia(Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<SyntaxToken> tokens)
    {
#if DEBUG
#endif

      return new SkippedTokensTriviaSyntax(SyntaxKind.SkippedTokensTrivia, tokens.Node, this.context);
    }
  }

  internal static partial class SyntaxFactory
  {
    public static XmlBodySyntax XmlBody(Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<XmlSyntaxNode> elements, SyntaxToken endOfFileToken)
    {
#if DEBUG
      if (endOfFileToken == null)
        throw new ArgumentNullException(nameof(endOfFileToken));
      switch (endOfFileToken.Kind)
      {
        case SyntaxKind.EndOfFileToken:
          break;
        default:
          throw new ArgumentException("endOfFileToken");
      }
#endif

      int hash;
      var cached = SyntaxNodeCache.TryGetNode((int)SyntaxKind.XmlBody, elements.Node, endOfFileToken, out hash);
      if (cached != null) return (XmlBodySyntax)cached;

      var result = new XmlBodySyntax(SyntaxKind.XmlBody, elements.Node, endOfFileToken);
      if (hash >= 0)
      {
          SyntaxNodeCache.AddNode(result, hash);
      }

      return result;
    }

    public static IdentifierNameSyntax IdentifierName(SyntaxToken identifier)
    {
#if DEBUG
      if (identifier == null)
        throw new ArgumentNullException(nameof(identifier));
      switch (identifier.Kind)
      {
        case SyntaxKind.IdentifierToken:
          break;
        default:
          throw new ArgumentException("identifier");
      }
#endif

      int hash;
      var cached = SyntaxNodeCache.TryGetNode((int)SyntaxKind.IdentifierName, identifier, out hash);
      if (cached != null) return (IdentifierNameSyntax)cached;

      var result = new IdentifierNameSyntax(SyntaxKind.IdentifierName, identifier);
      if (hash >= 0)
      {
          SyntaxNodeCache.AddNode(result, hash);
      }

      return result;
    }

    public static QualifiedNameSyntax QualifiedName(NameSyntax left, SyntaxToken dotToken, SimpleNameSyntax right)
    {
#if DEBUG
      if (left == null)
        throw new ArgumentNullException(nameof(left));
      if (dotToken == null)
        throw new ArgumentNullException(nameof(dotToken));
      switch (dotToken.Kind)
      {
        case SyntaxKind.DotToken:
          break;
        default:
          throw new ArgumentException("dotToken");
      }
      if (right == null)
        throw new ArgumentNullException(nameof(right));
#endif

      int hash;
      var cached = SyntaxNodeCache.TryGetNode((int)SyntaxKind.QualifiedName, left, dotToken, right, out hash);
      if (cached != null) return (QualifiedNameSyntax)cached;

      var result = new QualifiedNameSyntax(SyntaxKind.QualifiedName, left, dotToken, right);
      if (hash >= 0)
      {
          SyntaxNodeCache.AddNode(result, hash);
      }

      return result;
    }

    public static XmlElementSyntax XmlElement(XmlElementStartTagSyntax startTag, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<XmlSyntaxNode> content, XmlElementEndTagSyntax endTag)
    {
#if DEBUG
      if (startTag == null)
        throw new ArgumentNullException(nameof(startTag));
      if (endTag == null)
        throw new ArgumentNullException(nameof(endTag));
#endif

      int hash;
      var cached = SyntaxNodeCache.TryGetNode((int)SyntaxKind.XmlElement, startTag, content.Node, endTag, out hash);
      if (cached != null) return (XmlElementSyntax)cached;

      var result = new XmlElementSyntax(SyntaxKind.XmlElement, startTag, content.Node, endTag);
      if (hash >= 0)
      {
          SyntaxNodeCache.AddNode(result, hash);
      }

      return result;
    }

    public static XmlElementStartTagSyntax XmlElementStartTag(SyntaxToken lessThanToken, XmlNameSyntax name, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<XmlAttributeSyntax> attributes, SyntaxToken greaterThanToken)
    {
#if DEBUG
      if (lessThanToken == null)
        throw new ArgumentNullException(nameof(lessThanToken));
      switch (lessThanToken.Kind)
      {
        case SyntaxKind.LessThanToken:
          break;
        default:
          throw new ArgumentException("lessThanToken");
      }
      if (name == null)
        throw new ArgumentNullException(nameof(name));
      if (greaterThanToken == null)
        throw new ArgumentNullException(nameof(greaterThanToken));
      switch (greaterThanToken.Kind)
      {
        case SyntaxKind.GreaterThanToken:
          break;
        default:
          throw new ArgumentException("greaterThanToken");
      }
#endif

      return new XmlElementStartTagSyntax(SyntaxKind.XmlElementStartTag, lessThanToken, name, attributes.Node, greaterThanToken);
    }

    public static XmlElementEndTagSyntax XmlElementEndTag(SyntaxToken lessThanSlashToken, XmlNameSyntax name, SyntaxToken greaterThanToken)
    {
#if DEBUG
      if (lessThanSlashToken == null)
        throw new ArgumentNullException(nameof(lessThanSlashToken));
      switch (lessThanSlashToken.Kind)
      {
        case SyntaxKind.LessThanSlashToken:
          break;
        default:
          throw new ArgumentException("lessThanSlashToken");
      }
      if (name == null)
        throw new ArgumentNullException(nameof(name));
      if (greaterThanToken == null)
        throw new ArgumentNullException(nameof(greaterThanToken));
      switch (greaterThanToken.Kind)
      {
        case SyntaxKind.GreaterThanToken:
          break;
        default:
          throw new ArgumentException("greaterThanToken");
      }
#endif

      int hash;
      var cached = SyntaxNodeCache.TryGetNode((int)SyntaxKind.XmlElementEndTag, lessThanSlashToken, name, greaterThanToken, out hash);
      if (cached != null) return (XmlElementEndTagSyntax)cached;

      var result = new XmlElementEndTagSyntax(SyntaxKind.XmlElementEndTag, lessThanSlashToken, name, greaterThanToken);
      if (hash >= 0)
      {
          SyntaxNodeCache.AddNode(result, hash);
      }

      return result;
    }

    public static XmlEmptyElementSyntax XmlEmptyElement(SyntaxToken lessThanToken, XmlNameSyntax name, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<XmlAttributeSyntax> attributes, SyntaxToken slashGreaterThanToken)
    {
#if DEBUG
      if (lessThanToken == null)
        throw new ArgumentNullException(nameof(lessThanToken));
      switch (lessThanToken.Kind)
      {
        case SyntaxKind.LessThanToken:
          break;
        default:
          throw new ArgumentException("lessThanToken");
      }
      if (name == null)
        throw new ArgumentNullException(nameof(name));
      if (slashGreaterThanToken == null)
        throw new ArgumentNullException(nameof(slashGreaterThanToken));
      switch (slashGreaterThanToken.Kind)
      {
        case SyntaxKind.SlashGreaterThanToken:
          break;
        default:
          throw new ArgumentException("slashGreaterThanToken");
      }
#endif

      return new XmlEmptyElementSyntax(SyntaxKind.XmlEmptyElement, lessThanToken, name, attributes.Node, slashGreaterThanToken);
    }

    public static XmlNameSyntax XmlName(XmlPrefixSyntax prefix, SyntaxToken localName)
    {
#if DEBUG
      if (localName == null)
        throw new ArgumentNullException(nameof(localName));
      switch (localName.Kind)
      {
        case SyntaxKind.IdentifierToken:
          break;
        default:
          throw new ArgumentException("localName");
      }
#endif

      int hash;
      var cached = SyntaxNodeCache.TryGetNode((int)SyntaxKind.XmlName, prefix, localName, out hash);
      if (cached != null) return (XmlNameSyntax)cached;

      var result = new XmlNameSyntax(SyntaxKind.XmlName, prefix, localName);
      if (hash >= 0)
      {
          SyntaxNodeCache.AddNode(result, hash);
      }

      return result;
    }

    public static XmlPrefixSyntax XmlPrefix(SyntaxToken prefix, SyntaxToken colonToken)
    {
#if DEBUG
      if (prefix == null)
        throw new ArgumentNullException(nameof(prefix));
      switch (prefix.Kind)
      {
        case SyntaxKind.IdentifierToken:
          break;
        default:
          throw new ArgumentException("prefix");
      }
      if (colonToken == null)
        throw new ArgumentNullException(nameof(colonToken));
      switch (colonToken.Kind)
      {
        case SyntaxKind.ColonToken:
          break;
        default:
          throw new ArgumentException("colonToken");
      }
#endif

      int hash;
      var cached = SyntaxNodeCache.TryGetNode((int)SyntaxKind.XmlPrefix, prefix, colonToken, out hash);
      if (cached != null) return (XmlPrefixSyntax)cached;

      var result = new XmlPrefixSyntax(SyntaxKind.XmlPrefix, prefix, colonToken);
      if (hash >= 0)
      {
          SyntaxNodeCache.AddNode(result, hash);
      }

      return result;
    }

    public static XmlTextAttributeSyntax XmlTextAttribute(XmlNameSyntax name, SyntaxToken equalsToken, SyntaxToken startQuoteToken, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<SyntaxToken> textTokens, SyntaxToken endQuoteToken)
    {
#if DEBUG
      if (name == null)
        throw new ArgumentNullException(nameof(name));
      if (equalsToken == null)
        throw new ArgumentNullException(nameof(equalsToken));
      switch (equalsToken.Kind)
      {
        case SyntaxKind.EqualsToken:
          break;
        default:
          throw new ArgumentException("equalsToken");
      }
      if (startQuoteToken == null)
        throw new ArgumentNullException(nameof(startQuoteToken));
      switch (startQuoteToken.Kind)
      {
        case SyntaxKind.SingleQuoteToken:
        case SyntaxKind.DoubleQuoteToken:
          break;
        default:
          throw new ArgumentException("startQuoteToken");
      }
      if (endQuoteToken == null)
        throw new ArgumentNullException(nameof(endQuoteToken));
      switch (endQuoteToken.Kind)
      {
        case SyntaxKind.SingleQuoteToken:
        case SyntaxKind.DoubleQuoteToken:
          break;
        default:
          throw new ArgumentException("endQuoteToken");
      }
#endif

      return new XmlTextAttributeSyntax(SyntaxKind.XmlTextAttribute, name, equalsToken, startQuoteToken, textTokens.Node, endQuoteToken);
    }

    public static XmlNameAttributeSyntax XmlNameAttribute(XmlNameSyntax name, SyntaxToken equalsToken, SyntaxToken startQuoteToken, IdentifierNameSyntax identifier, SyntaxToken endQuoteToken)
    {
#if DEBUG
      if (name == null)
        throw new ArgumentNullException(nameof(name));
      if (equalsToken == null)
        throw new ArgumentNullException(nameof(equalsToken));
      switch (equalsToken.Kind)
      {
        case SyntaxKind.EqualsToken:
          break;
        default:
          throw new ArgumentException("equalsToken");
      }
      if (startQuoteToken == null)
        throw new ArgumentNullException(nameof(startQuoteToken));
      switch (startQuoteToken.Kind)
      {
        case SyntaxKind.SingleQuoteToken:
        case SyntaxKind.DoubleQuoteToken:
          break;
        default:
          throw new ArgumentException("startQuoteToken");
      }
      if (identifier == null)
        throw new ArgumentNullException(nameof(identifier));
      if (endQuoteToken == null)
        throw new ArgumentNullException(nameof(endQuoteToken));
      switch (endQuoteToken.Kind)
      {
        case SyntaxKind.SingleQuoteToken:
        case SyntaxKind.DoubleQuoteToken:
          break;
        default:
          throw new ArgumentException("endQuoteToken");
      }
#endif

      return new XmlNameAttributeSyntax(SyntaxKind.XmlNameAttribute, name, equalsToken, startQuoteToken, identifier, endQuoteToken);
    }

    public static XmlTextSyntax XmlText(Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<SyntaxToken> textTokens)
    {
#if DEBUG
#endif

      int hash;
      var cached = SyntaxNodeCache.TryGetNode((int)SyntaxKind.XmlText, textTokens.Node, out hash);
      if (cached != null) return (XmlTextSyntax)cached;

      var result = new XmlTextSyntax(SyntaxKind.XmlText, textTokens.Node);
      if (hash >= 0)
      {
          SyntaxNodeCache.AddNode(result, hash);
      }

      return result;
    }

    public static XmlCDataSectionSyntax XmlCDataSection(SyntaxToken startCDataToken, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<SyntaxToken> textTokens, SyntaxToken endCDataToken)
    {
#if DEBUG
      if (startCDataToken == null)
        throw new ArgumentNullException(nameof(startCDataToken));
      switch (startCDataToken.Kind)
      {
        case SyntaxKind.XmlCDataStartToken:
          break;
        default:
          throw new ArgumentException("startCDataToken");
      }
      if (endCDataToken == null)
        throw new ArgumentNullException(nameof(endCDataToken));
      switch (endCDataToken.Kind)
      {
        case SyntaxKind.XmlCDataEndToken:
          break;
        default:
          throw new ArgumentException("endCDataToken");
      }
#endif

      int hash;
      var cached = SyntaxNodeCache.TryGetNode((int)SyntaxKind.XmlCDataSection, startCDataToken, textTokens.Node, endCDataToken, out hash);
      if (cached != null) return (XmlCDataSectionSyntax)cached;

      var result = new XmlCDataSectionSyntax(SyntaxKind.XmlCDataSection, startCDataToken, textTokens.Node, endCDataToken);
      if (hash >= 0)
      {
          SyntaxNodeCache.AddNode(result, hash);
      }

      return result;
    }

    public static XmlProcessingInstructionSyntax XmlProcessingInstruction(SyntaxToken startProcessingInstructionToken, XmlNameSyntax name, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<SyntaxToken> textTokens, SyntaxToken endProcessingInstructionToken)
    {
#if DEBUG
      if (startProcessingInstructionToken == null)
        throw new ArgumentNullException(nameof(startProcessingInstructionToken));
      switch (startProcessingInstructionToken.Kind)
      {
        case SyntaxKind.XmlProcessingInstructionStartToken:
          break;
        default:
          throw new ArgumentException("startProcessingInstructionToken");
      }
      if (name == null)
        throw new ArgumentNullException(nameof(name));
      if (endProcessingInstructionToken == null)
        throw new ArgumentNullException(nameof(endProcessingInstructionToken));
      switch (endProcessingInstructionToken.Kind)
      {
        case SyntaxKind.XmlProcessingInstructionEndToken:
          break;
        default:
          throw new ArgumentException("endProcessingInstructionToken");
      }
#endif

      return new XmlProcessingInstructionSyntax(SyntaxKind.XmlProcessingInstruction, startProcessingInstructionToken, name, textTokens.Node, endProcessingInstructionToken);
    }

    public static XmlCommentSyntax XmlComment(SyntaxToken lessThanExclamationMinusMinusToken, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<SyntaxToken> textTokens, SyntaxToken minusMinusGreaterThanToken)
    {
#if DEBUG
      if (lessThanExclamationMinusMinusToken == null)
        throw new ArgumentNullException(nameof(lessThanExclamationMinusMinusToken));
      switch (lessThanExclamationMinusMinusToken.Kind)
      {
        case SyntaxKind.XmlCommentStartToken:
          break;
        default:
          throw new ArgumentException("lessThanExclamationMinusMinusToken");
      }
      if (minusMinusGreaterThanToken == null)
        throw new ArgumentNullException(nameof(minusMinusGreaterThanToken));
      switch (minusMinusGreaterThanToken.Kind)
      {
        case SyntaxKind.XmlCommentEndToken:
          break;
        default:
          throw new ArgumentException("minusMinusGreaterThanToken");
      }
#endif

      int hash;
      var cached = SyntaxNodeCache.TryGetNode((int)SyntaxKind.XmlComment, lessThanExclamationMinusMinusToken, textTokens.Node, minusMinusGreaterThanToken, out hash);
      if (cached != null) return (XmlCommentSyntax)cached;

      var result = new XmlCommentSyntax(SyntaxKind.XmlComment, lessThanExclamationMinusMinusToken, textTokens.Node, minusMinusGreaterThanToken);
      if (hash >= 0)
      {
          SyntaxNodeCache.AddNode(result, hash);
      }

      return result;
    }

    public static SkippedTokensTriviaSyntax SkippedTokensTrivia(Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<SyntaxToken> tokens)
    {
#if DEBUG
#endif

      return new SkippedTokensTriviaSyntax(SyntaxKind.SkippedTokensTrivia, tokens.Node);
    }

    internal static IEnumerable<Type> GetNodeTypes()
    {
        return new Type[] {
           typeof(XmlBodySyntax),
           typeof(IdentifierNameSyntax),
           typeof(QualifiedNameSyntax),
           typeof(XmlElementSyntax),
           typeof(XmlElementStartTagSyntax),
           typeof(XmlElementEndTagSyntax),
           typeof(XmlEmptyElementSyntax),
           typeof(XmlNameSyntax),
           typeof(XmlPrefixSyntax),
           typeof(XmlTextAttributeSyntax),
           typeof(XmlNameAttributeSyntax),
           typeof(XmlTextSyntax),
           typeof(XmlCDataSectionSyntax),
           typeof(XmlProcessingInstructionSyntax),
           typeof(XmlCommentSyntax),
           typeof(SkippedTokensTriviaSyntax)
        };
    }
  }
}
